{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Somap is a flexible, fast and scalable Self-Organizing Maps library in python. It allows you to define and run different flavors of SOMs (Kohonen, DSOM or your custom ones) on square or hexagonal 2D grid, with or without toroidal topology.</p> <p> </p>"},{"location":"#why-a-new-som-library","title":"Why a new SOM library?","text":"<p>There are already a few open-source libraries for Self-Organizing Maps in python, of which MiniSom and SOMPY seem to be the most popular. I developped Somap to overcome what I believe to be two shortcomings of existing libraries for my research on bio-inspired AI: </p> <ul> <li>Ability to easily customize the SOM algorithm (e.g. distance, neighborhood, learning rate and update functions).</li> <li>Capacity to vectorize the computations over many SOMs (e.g. for distributed learning over 2D maps of SOMs).</li> </ul> <p>Thanks to JAX's <code>jit</code> and <code>vmap</code> magic functions, it turned out that performance was also significantly better compared to other frameworks. Under the hood, it relies indirectly on JAX via the Equinox library that offers an easy-to-use PyTorch-like syntax.</p>"},{"location":"#installation","title":"Installation","text":"<p>Requires Python 3.10+ and a working installation of JAX 0.4.20+. You can follow these instructions to install JAX with the relevant hardware acceleration support.</p> <p>Then:</p> <pre><code>pip install somap\n</code></pre>"},{"location":"#quick-example","title":"Quick example","text":"<p>The classic workflow goes as follow: <pre><code>import somap as smp\n\n# Load the MNIST dataset as a Numpy array of shape (60000, 28, 28)\ndata = smp.datasets.MNIST().data\n\n# Initialize the 2D map\nmodel = smp.StaticKsom(\n    shape = (11, 13), \n    topography = \"hex\", \n    borderless = False, \n    input_shape = (28, 28), \n    params = smp.StaticKsomParams(sigma=0.3, alpha=0.5)\n)\n\n# Train (see documentation to understand the \"bu_v\" dict key)\nmodel, aux = smp.make_steps(model, {\"bu_v\": data})\n\n# Plot the 2D map \nsmp.plot(model)\n\n# Retrieve the errors from all steps\nquantization_errors = aux[\"metrics\"][\"quantization_error\"]\ntopographic_errors = aux[\"metrics\"][\"topographic_error\"]\n</code></pre></p> <p>You can also define your custom SOM: <pre><code>import somap as smp\nfrom jaxtyping import Array, Float\n\nclass MyCustomSomParams(smp.AbstractSomParams):\n    sigma: float | Float[Array, \"...\"]\n    alpha: float | Float[Array, \"...\"]\n\nclass MyCustomSom(smp.AbstractSom):\n\n    @staticmethod\n    def generate_algo(p: MyCustomSomParams) -&gt; smp.SomAlgo:\n        return smp.SomAlgo(\n            f_dist=smp.EuclidianDist(),\n            f_nbh=smp.GaussianNbh(sigma=p.sigma),\n            f_lr=smp.ConstantLr(alpha=p.alpha),\n            f_update=smp.SomUpdate(),\n        )\n</code></pre></p> <p>If you need custom distance, neighborhood, learning rate and update functions for your SOM, you can define them by inheriting from <code>smp.AbstractDist</code>, <code>smp.AbstractNbh</code>, <code>smp.AbstractLr</code> and <code>smp.AbstractUpdate</code>. See the library source code for how to do it.</p>"},{"location":"#next-steps","title":"Next steps","text":"<p>I am currently working on different ways to extend the basic SOM algorithm:</p> <ul> <li>Inputs: In addition to classic bottom-up driving inputs, a SOM could also receive lateral contextual or top-down modulatory inputs.</li> <li>Weighted inputs: Each data point from inputs can be weighted so that fuzzy data is weighted less for the winner selection.</li> <li>Dynamics: When receiving continuous inputs in time, past activations can influence the computation of the next step.</li> <li>Supervised and self-supervised learning: Top-down inputs and next inputs in time can act as teaching signal for supervised and self-supervised learning.</li> <li>Multi-agent system: Each SOM is an agent of a mutli-agent system where thousands of SOMs interact with each other.</li> </ul> <p>Some of these features will land on an other library that depends on Somap.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you found this library to be useful in academic work, then please cite: <pre><code>@misc{thiboust2023somap,\n  title={Somap: a flexible, fast and scalable python library for Self-Organizing Maps.},\n  author={Matthieu Thiboust},\n  year={2023},\n  url={https://github.com/mthiboust/somap/},\n}\n</code></pre></p>"},{"location":"all_of_somap/","title":"All of Somap","text":"<p>A self-organizing map (SOM) is a type of artificial neural network that is trained using unsupervised learning to produce a low-dimensional, typically two-dimensional, representation of input data. It's like a map that organizes itself to represent different patterns or features found in the input data, arranging similar data close together and dissimilar data far apart. This makes it useful for visualizing complex data in a way that highlights its inherent similarities and differences.</p>"},{"location":"all_of_somap/#input-data","title":"Input data","text":"<p>SOMs can take any kind of input data as long as it can be represented as vectors of values. For example, a 28x28 MNIST image will be internally represented as a flatten vector of 784 values. You can directly pass your unflatten values to a Somap SOM so that it remembers the shape of your data during the rendering step.</p> <p>To help you test quickly your SOMs against common datasets, you can load them via <code>somap.datasets</code>:</p> <pre><code>import somap as smp\n\n# Load the MNIST dataset as a Numpy array of shape (60000, 28, 28)\ndata = smp.datasets.MNIST().data\n</code></pre> <p>See this page for a list of integrated datasets.</p> Upcoming versions <p>In addition to classic bottum-up driving inputs described above, future versions of Somap will support extra inputs for lateral contextual and top-down modulatory inputs.</p>"},{"location":"all_of_somap/#creating-soms","title":"Creating SOMs","text":""},{"location":"all_of_somap/#universal-parameters","title":"Universal parameters","text":"<p>In Somap, SOMs are defined by:</p> <ul> <li>A shape: Tuple of 2 ints (Somap only support 2 dimensional maps).</li> <li>A topology: Either 'square' for regular square grid, or 'hex' for hexagonal grid.An hexagonal grid has a finer resolution when dealing with near neighborhood (6 direct neighbors vs 4 for the square grid).</li> <li>A borderless option: If True, the 2D map joins its opposite borders like in a tore. A borderless map has the advantage of not privileging any node of the map. Otherwise, corner- and border-nodes are generally over-activated as a result of arranging dissimilar data far apart.</li> <li>An input_shape: Tuple of ints. Necessary to initialize the prototype weights matrix.</li> <li>The params of the specific SOM model: Depends on the chosen SOM.</li> </ul> <p>The SOM algorithm involves initializing a grid of nodes, each with a randomly assigned weight vector. During training, each input data point is compared to all nodes, and the node with the weight vector most similar to the input (the \"Best Matching Unit\", aka BMU) is identified. The weights of this node and its neighbors are then adjusted to become more like the input data, gradually organizing the grid so that similar data points are mapped to nearby nodes.</p> <p>Different kinds of SOMs can be imagined depending on:</p> <ul> <li>The distance function: how each input data point is compared to all node.</li> <li>The neighborhood function: how much each node is considered depending on its distance to the BMU.</li> <li>The learning rate function: how much the weights are updated at each step.</li> <li>The update function: how is the update performed.</li> </ul>"},{"location":"all_of_somap/#static-kohonen-som","title":"Static Kohonen SOM","text":"<p>The simplest SOM available in Somap is a time-independent version of the Kohonen SOM, called <code>StaticKsom</code>. It is defined by 2 parameters: </p> <ul> <li><code>sigma</code>: The width of the Gaussian neighborhood function around the Best Matching Unit (BMU). A larger sigma value means a wider neighborhood, where more nodes are influenced significantly during each training step. The influence of the BMU on neighboring nodes decreases with distance in a Gaussian manner, meaning nodes closer to the BMU are adjusted more significantly than those further away.</li> <li><code>alpha</code>: The learning rate for the SOM. It dictates how much the weights of the nodes in the network are adjusted in response to each input data point.</li> </ul> <pre><code>model = smp.StaticKsom(\n    shape = (11, 13), \n    topography = \"hex\", \n    borderless = False, \n    input_shape = (28, 28), \n    params = smp.KsomParams(sigma=0.3, alpha=0.5)\n)\n</code></pre>"},{"location":"all_of_somap/#kohonen-som","title":"Kohonen SOM","text":"<p>The classic Kohonen SOM is defined by the following parameters:</p> <ul> <li><code>t_f</code>: The final time or iteration step of the training process. It represents when the training of the SOM will end. The training typically involves gradually decreasing the learning rate and the neighborhood radius over time.</li> <li><code>sigma_i</code> and <code>sigma_f</code>: The initial and final values of the width of the Gaussian neighborhood function around the Best Matching Unit (BMU). A larger sigma value means a wider neighborhood, where more nodes are influenced significantly during each training step. <code>sigma_i</code> is larger to allow broader learning initially, and <code>sigma_f</code> is smaller, focusing the learning more locally towards the end of training.</li> <li><code>alpha_i</code> and <code>alpha_f</code>: The initial and final learning rates. The learning rate controls how much the weights of the SOM nodes are adjusted during training. A higher initial learning rate allows the network to quickly adapt to the data, while the lower final rate allows for finer adjustments as the training progresses.</li> </ul> <pre><code>model = smp.Ksom(\n    shape = (11, 13), \n    topography = \"hex\", \n    borderless = False, \n    input_shape = (28, 28), \n    params = smp.KsomParams(\n        t_f=60000, \n        sigma_i=0.7, \n        sigma_f=0.01, \n        alpha_i=0.1, \n        alpha_f=0.001\n    )\n)\n</code></pre>"},{"location":"all_of_somap/#dynamic-som","title":"Dynamic SOM","text":"<p>The Dynamic SOM was introduced by N. Rougier and Y. Boniface in 2011. It is a variation of the self-organising map algorithm where the original time-dependent (learning rate and neighbourhood) learning function is replaced by a time-invariant one. This allows for on-line and continuous learning on both static and dynamic data distributions.</p> <p>Reference</p> <p>Nicolas P. Rougier, Yann Boniface. Dynamic Self-Organising Map.  Neurocomputing, Elsevier, 2011, 74 (11), pp.1840-1847. ff10.1016/j.neucom.2010.06.034ff. ffinria-00495827</p> <ul> <li><code>plasticity</code>: This parameter controls the overall ability of the network to adapt to new data over time. High plasticity allows the network to change rapidly in response to new data, making it more flexible but potentially less stable. Lower plasticity means slower adaptation, leading to more stability but less responsiveness to new or changing patterns in the data.</li> <li><code>alpha</code>: Similar to traditional SOMs, alpha in the Dynamic SOM represents the learning rate. It determines the extent to which the weights of the nodes are adjusted in response to each input data point. This parameter works in conjunction with the <code>plasticity</code> parameter to regulate the network's adaptation to the input data over time.</li> </ul> <pre><code>model = smp.Dsom(\n    shape = (11, 13), \n    topography = \"hex\", \n    borderless = False, \n    input_shape = (28, 28), \n    params = smp.DsomParams(alpha=0.001, plasticity=0.02)\n)\n</code></pre>"},{"location":"all_of_somap/#custom-sm","title":"Custom SM","text":"<p>You can also define your custom SOM by choosing functions over the existing catalog:</p> <pre><code>import somap as smp\nfrom jaxtyping import Array, Float\n\nclass MyCustomSomParams(smp.AbstractSomParams):\n    sigma: float | Float[Array, \"...\"]\n    alpha: float | Float[Array, \"...\"]\n\nclass MyCustomSom(smp.AbstractSom):\n\n    @staticmethod\n    def generate_algo(p: MyCustomSomParams) -&gt; smp.SomAlgo:\n        return smp.SomAlgo(\n            f_dist=smp.EuclidianDist(),\n            f_nbh=smp.GaussianNbh(sigma=p.sigma),\n            f_lr=smp.ConstantLr(alpha=p.alpha),\n            f_update=smp.SomUpdate(),\n        )\n</code></pre> <p>If you need custom distance, neighborhood, learning rate and update functions for your SOM, you can define them by inheriting from <code>smp.AbstractDist</code>, <code>smp.AbstractNbh</code>, <code>smp.AbstractLr</code> and <code>smp.AbstractUpdate</code>. See the library source code for how to do it.</p>"},{"location":"all_of_somap/#running-soms","title":"Running SOMs","text":"<p>SOMs utilize online learning, continuously updating their weights after processing each input. Due to JAX's immutable nature, SOM models are generated as new objects at every step. Additionally, an auxiliary variable is returned, containing metrics or information for debugging purposes.</p> <p>For running a single step: <pre><code>data = ... # Array whose leading axis represents the different data examples\n\n# Do a single iteration on the first element of data\nmodel, aux = smp.make_step(model, {\"bu_v\": data[0]})\n</code></pre></p> <p>For running multiple steps when input data is known in advance, prefer the more optimized <code>somap.make_steps</code> function: <pre><code>data = ... # Array whose leading axis represents the different data examples\n\n# Iterate over all the elements in `data`\nmodel, aux = smp.make_steps(model, {\"bu_v\": data})\n</code></pre></p>"},{"location":"all_of_somap/#visualizing-soms","title":"Visualizing SOMs","text":"<p><code>Somap</code> comes with several plotting backends to visualize a SOM. </p>"},{"location":"all_of_somap/#altair","title":"Altair","text":"<p>The default plotting backend relies on the <code>altair</code> plotting library. This enables the dynamic rendering of both square and hexagonal grids. Additionally, tooltips are provided to offer supplementary information when hovering the mouse over a node.</p> <p>Show the prototypes: <pre><code>import matplotlib\nsmp.plot(model, show_prototypes=True, show_activity=False, img_inverted_colors=True, img_cmap=matplotlib.cm.gnuplot2)\n</code></pre></p> <p></p> <p>Show the activity of each node (how many times they have been activated): <pre><code>import matplotlib\nsmp.plot(model, show_prototypes=False, show_activity=True)\n</code></pre></p> <p></p> <p>Impact of the <code>borderless</code> parameter</p> <p>This is a map with <code>borderless=False</code>. You can observe the unequal repartition of activity between the nodes, with a high biais toward corners and borders. A borderless map won't have this effect.</p> <p>See this page for details about available options.</p>"},{"location":"all_of_somap/#array2image","title":"Array2image","text":"<p>This plotting backend leverages the <code>array2image</code> library, offering a quicker and more direct method for rendering square grids.</p> <p>To use this backend, set the following environment variable: <code>SOMAP_PLOT_BACKEND=array2image</code></p> <pre><code>smp.plot(model, inverted_colors=True, cmap=matplotlib.cm.gnuplot2)\n</code></pre> <p></p> <p>See this page for details about available options.</p>"},{"location":"all_of_somap/#evaluating-soms","title":"Evaluating SOMs","text":"<p>Evaluating SOMs typically involves the following metrics:</p> <ul> <li>Quantization Error: Measures the average distance between each data point and its Best Matching Unit (BMU) on the map. A lower quantization error indicates a more accurate representation of the input data on the map.</li> <li>Topographic Error: Assesses the continuity and topology preservation of the map by measuring the average distance between the first and second BMUs. A lower topographic error suggests better preservation of the input data's topology.</li> </ul> <p>Those metrics are available in the auxilarry data returned by the <code>somap.make_step</code> and <code>somap.make_steps</code> functions.</p> <pre><code># Iterate over all the elements in `data`\nmodel, aux = smp.make_steps(model, {\"bu_v\": data})\n\n# Retrieve the errors from all steps\nquantization_errors = aux[\"metrics\"][\"quantization_error\"]\ntopographic_errors = aux[\"metrics\"][\"topographic_error\"]\n</code></pre>"},{"location":"all_of_somap/#saving-and-loading-soms","title":"Saving and loading SOMs","text":"<p>You can save and load SOM models via the following functions (which act as a pass-through the corresponding Equinox functions because SOM models are Equinox modules).</p> <pre><code># Initialize and train a SOM\nmodel = ...\n\n# Save a SOM model\nsmp.save(\"my_som.smp\", model)\n\n# Load a SOM model having the same structure as `model` \n# which can typically be the model initialization without any training\nsmp.load(\"my_som.smp\", model)\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#why-the-input-data-is-passed-as-a-dictionary-with-the-bu_v-key","title":"Why the input data is passed as a dictionary with the \"bu_v\" key?","text":"<p>I intend to add support for other kind of data in the future. A more complex variant of SOM may take additional inputs that could be categorized into:</p> <ul> <li>\"bu\": Bottom-up driving input (the classic input of SOMs)</li> <li>\"lat\": Lateral contextual input which could influence the processing before selecting the BMU.</li> <li>\"td\": Top-down modulatory input which could influence the selection of the BMU.</li> </ul> <p>The \"v\" and \"m\" suffixes correspond respectively to value and mask for supporting weighted inputs.</p>"},{"location":"faq/#i-want-to-keep-track-of-the-auxilary-data-of-my-model-across-different-calls-to-smpmake_step-or-smpmake_steps","title":"I want to keep track of the auxilary data of my model across different calls to <code>smp.make_step</code> or <code>smp.make_steps</code>","text":"<p>You can keep track of the auxilary data of your models in a list that is merged at the end:</p> <pre><code>epoch = 10\nauxs = []\nfor i in range(0, epoch):\n    model, aux = smp.make_steps(model, {\"bu_v\": data})\n    auxs.append(aux)\n\n# Concatenate the 'aux' outputs if there are several\naux = jax.tree_util.tree_map(\n    lambda x, *y: np.concatenate((x, *y), axis=0),\n    *auxs,\n    is_leaf=lambda x: isinstance(x, list),\n)\n</code></pre>"},{"location":"hyperparameters_tuning/","title":"Hyperparameter exploration","text":"<pre><code># Imports\nimport equinox as eqx\nimport jax.numpy as jnp\nimport somap as smp\nfrom array2image import array_to_image  # to easily vizualize the results\n</code></pre> <pre>\n<code>An NVIDIA GPU may be present on this machine, but a CUDA-enabled jaxlib is not installed. Falling back to cpu.\n</code>\n</pre> <pre><code># Load the MNIST dataset as a Numpy array of shape (60000, 28, 28)\ndata = smp.datasets.MNIST().data\n</code></pre> <pre><code># Vectorize over the two hyperparamters of StaticKsom\n@eqx.filter_vmap(in_axes=(None, 0))\n@eqx.filter_vmap(in_axes=(0, None))\ndef myArrayOfStaticKsom(sigma, alpha):\n    return smp.StaticKsom(\n        shape=(10, 10),\n        topography=\"square\",\n        borderless=True,\n        input_shape=(28, 28),\n        params=smp.StaticKsomParams(sigma=sigma, alpha=alpha),\n    )\n\n\n# List of hyperparameters to test\nsigmas = jnp.linspace(0.05, 0.2, 4)\nalphas = jnp.linspace(0.001, 0.05, 3)\n\nmodel = myArrayOfStaticKsom(sigmas, alphas)\nmodel\n</code></pre> <pre>\n<code>StaticKsom(\n  shape=(10, 10),\n  topography='square',\n  borderless=True,\n  input_shape=(28, 28),\n  params=StaticKsomParams(sigma=f32[3,4], alpha=f32[3,4]),\n  metrics=True,\n  debug=False,\n  algo=SomAlgo(\n    f_dist=EuclidianDist(),\n    f_nbh=GaussianNbh(sigma=f32[3,4]),\n    f_lr=ConstantLr(alpha=f32[3,4]),\n    f_update=SomUpdate()\n  ),\n  in_size=784,\n  t=i32[3,4],\n  w_bu=f32[3,4,10,10,28,28],\n  i_act_nb=i32[3,4,10,10],\n  winner=i32[3,4,2]\n)</code>\n</pre> <pre><code># Vectorize the `make_steps` functions over all 'Array' params of our model\n@eqx.filter_vmap(in_axes=(eqx.if_array(0), None))\n@eqx.filter_vmap(in_axes=(eqx.if_array(0), None))\ndef make_steps(model, inputs):\n    return smp.make_steps(model, inputs)\n</code></pre> <pre><code># Run our 3x4 SOMs on the 60k MNIST images\nmodel, aux = make_steps(model, {\"bu_v\": data})\n</code></pre> <pre><code>array_to_image(model.w_bu)\n</code></pre>"},{"location":"hyperparameters_tuning/#hyperparameters-exploration-via-soms-vectorization","title":"Hyperparameters exploration via SOMs vectorization","text":"<p>In Self-Organizing Maps, hyperparameters like the neighborhood size or the learning rate are not easy to fine tune. It is often a process of trials and errors that need multiple iterations. To facilitate this exploration, <code>somap</code> SOMs can be vectorized along multiple axis to test in parallel the combination of different hyperparameters.</p> <p>Here is an example testing the combination of multiple <code>sigma</code> and <code>alpha</code> values for a simple static Kohonen SOM:</p>"},{"location":"mnist/","title":"MNIST","text":"<pre><code>%reset -f\n\nimport jax\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom array2image import array_to_image\n\nimport somap as smp\n</code></pre> <pre><code>data = smp.datasets.MNIST().data\n\nprint(f\"Shape of dataset: {data.shape}\")\nprint(f\"Some data samples:\")\n\narray_to_image(data[:20])\n</code></pre> <pre>\n<code>Shape of dataset: (60000, 28, 28)\nSome data samples:\n</code>\n</pre> <pre><code># SOM generic parameters:\nshape = (12, 12)\ntopography = \"square\"\nborderless = False\ninput_shape = (28, 28)\n\nsom_type = \"ksom\"\n\nif som_type == \"ksom\":  # Kohonen\n    params = smp.KsomParams(\n        t_f=60000, sigma_i=0.7, sigma_f=0.01, alpha_i=0.1, alpha_f=0.001\n    )\n    model = smp.Ksom(shape, topography, borderless, input_shape, params)\n\nelif som_type == \"dsom\":  # Dynamic SOM\n    params = smp.DsomParams(alpha=0.001, plasticity=0.02)\n    model = smp.Dsom(shape, topography, borderless, input_shape, params)\n\nprint(\"Visualisation of the weight values of each node:\")\nsmp.plot(\n    model,\n    show_prototypes=True,\n    show_activity=False,\n)\n</code></pre> <pre>\n<code>Visualisation of the weight values of each node:\n</code>\n</pre> <p>Train the model:</p> <pre><code>epoch = 1\nauxs = []\nfor i in range(0, epoch):\n    model, aux = smp.make_steps(model, {\"bu_v\": data})\n    auxs.append(aux)\n\n# Concatenate the 'aux' outputs if there are several\naux = jax.tree_util.tree_map(\n    lambda x, *y: np.concatenate((x, *y), axis=0),\n    *auxs,\n    is_leaf=lambda x: isinstance(x, list),\n)\n\nprint(f\"Nb of data samples viewed by the model: {epoch * data.shape[0]}\")\n\nsmp.plot(model, show_prototypes=True, show_activity=False, img_inverted_colors=True)\n</code></pre> <pre>\n<code>Nb of data samples viewed by the model: 60000\n</code>\n</pre> <pre><code>def moving_average(x, w):\n    return np.convolve(x, np.ones(w), \"valid\") / w\n\n\nerrors = aux[\"metrics\"][\"quantization_error\"]\nplt.plot(moving_average(errors, 100))\n</code></pre> <pre>\n<code>[&lt;matplotlib.lines.Line2D at 0x7f8b684249d0&gt;]</code>\n</pre> <p>Show the topographic error:</p> <p>Note: An error of 1/sqrt(w,h) (where w is the width and h is the height of the map) means that the two best winning nodes are neighbors</p> <pre><code>errors = aux[\"metrics\"][\"topographic_error\"]\nplt.plot(moving_average(errors, 100))\n</code></pre> <pre>\n<code>[&lt;matplotlib.lines.Line2D at 0x7f8b443964d0&gt;]</code>\n</pre>"},{"location":"mnist/#self-organizing-maps-on-the-mnist-dataset","title":"Self-Organizing Maps on the MNIST dataset","text":"<p>This notebook shows a standard Kohonen SOM (KSOM) and a Dynamic SOM (DSOM) on the MNIST dataset. The MNIST dataset consists of 60k 28x28 grayscale images of figures from 0 to 9. The goal is to project those images on a small 2D map where nearby nodes correspond to nearby images.</p>"},{"location":"mnist/#data","title":"Data","text":"<p>Load the MNIST dataset and show the first elements</p>"},{"location":"mnist/#model","title":"Model","text":"<p>Initialize the SOM (Kohonon or DSOM):</p>"},{"location":"mnist/#evaluation","title":"Evaluation","text":"<p>Show the quantization error:</p>"},{"location":"api/core/","title":"Core","text":"<p>Abstract base classes for defining SOMs.</p>"},{"location":"api/core/#somap.core.AbstractSom","title":"<code>AbstractSom</code>","text":"<p>             Bases: <code>Module</code></p> <p>Abstract base class for SOM models.</p> Source code in <code>src/somap/core.py</code> <pre><code>class AbstractSom(eqx.Module):\n    \"\"\"Abstract base class for SOM models.\"\"\"\n\n    shape: tuple\n    topography: str\n    borderless: bool\n    input_shape: tuple\n    params: AbstractSomParams\n    metrics: bool = True\n    debug: bool = False\n    algo: SomAlgo = eqx.field(init=False)\n    in_size: int = eqx.field(init=False)\n    t: Integer[Array, \"\"] = eqx.field(init=False)\n    w_bu: Float[Array, \"x y ...\"] = eqx.field(init=False)  # same as \"prototype weights\"\n    i_act_nb: Integer[Array, \"x y\"] = eqx.field(init=False)\n    winner: Integer[Array, \"2\"] = eqx.field(init=False)\n\n    def __init__(\n        self,\n        shape,\n        topography,\n        borderless,\n        input_shape,\n        params,\n        metrics=True,\n        debug=False,\n        key: PRNGKeyArray = jax.random.PRNGKey(0),\n    ):\n        \"\"\"Creates a SOM models.\n\n        Args:\n            shape: Shape of the 2D map.\n            topography: Topography of the 2D map. Either 'square' for a square grid\n                or 'hex' for hexagonal grid.\n            borderless: Toroidal topography if True, meaning that the top (resp. left)\n                border meets the bottom (resp. right) border.\n            input_shape: Shape of the input data.\n            params: Parameters of the SOM (depends on the SOM flavor).\n            metrics: If True, returns quantization and topographic errors as auxilary\n                data.\n            debug: If True, returns debug data as auxilary data.\n            key: JAX random key used during map initialization.\n        \"\"\"\n        self.shape = shape\n        self.topography = topography\n        self.borderless = borderless\n        self.input_shape = input_shape\n        self.params = params\n        self.metrics = metrics\n        self.debug = debug\n\n        self.in_size = int(np.prod(self.input_shape))\n        self.t = jnp.array(0, dtype=jnp.int32)\n        self.w_bu = jax.random.uniform(\n            key, (self.shape + self.input_shape), dtype=jnp.float32\n        )\n        self.i_act_nb = jnp.zeros(self.shape, dtype=jnp.int32)\n        self.algo = self.generate_algo(params)\n        self.winner = jnp.zeros((2,), dtype=jnp.int32)\n\n    @abstractstaticmethod\n    def generate_algo(params: AbstractSomParams) -&gt; SomAlgo:\n        \"\"\"Converts specific SOM parameters into generic SOM functions.\"\"\"\n        raise NotImplementedError\n\n    def __call__(self, input: InputData):\n        \"\"\"Makes a single iteration.\n\n        Args:\n            input: Data array for the given SOM models.\n\n        Returns:\n            A tuple with the new SOM model and the auxilary data.\n        \"\"\"\n        input_bu_v = input[\"bu_v\"].reshape(self.in_size)\n        w_bu = self.w_bu.reshape((self.shape) + (self.in_size,))\n\n        # Compute distances over the 2D grid\n        f_dist = jax.vmap(\n            jax.vmap(self.algo.f_dist, in_axes=(0, None)), in_axes=(0, None)\n        )\n        dist = f_dist(w_bu, input_bu_v)\n\n        # Find the coordinates of the node with the minimal distance\n        x, y = jnp.unravel_index(jnp.argmin(dist), dist.shape)\n        winner = jnp.array([x, y])\n\n        if self.metrics:\n            # Find the second winner (replace the winner by a high value,\n            # then compute the `argmin` which is faster than a whole `argsort`)\n            x2, y2 = jnp.unravel_index(\n                jnp.argmin(dist.at[x, y].set(dist.max())), dist.shape\n            )\n\n        # Compute the neighbourhood 2D grid values\n        d = distance_map(self.shape, winner, self.topography, self.borderless)\n        nbh = self.algo.f_nbh(d, self.t, dist[x, y])\n\n        # Compute the learning rate for the 2D grid\n        lr = self.algo.f_lr(self.t, dist)\n\n        # Update model parameters\n        new_self = self.bulk_set(\n            {\n                \"w_bu\": self.algo.f_update(lr, nbh, input_bu_v, w_bu).reshape(\n                    (self.shape + self.input_shape)\n                ),\n                \"i_act_nb\": self.i_act_nb.at[x, y].set((1 + self.i_act_nb[x, y])),\n                \"t\": self.t + 1,\n                \"winner\": winner,\n            }\n        )\n\n        aux = {}\n        if self.metrics:\n            aux[\"metrics\"] = {\n                \"quantization_error\": dist[x, y],\n                \"topographic_error\": d[x2, y2],\n            }\n        if self.debug:\n            aux[\"debug\"] = {\n                \"dist\": dist,\n                \"nbh\": nbh,\n                \"lr\": lr,\n            }\n\n        return new_self, aux\n\n    def set(self, attribute: str, value):\n        \"\"\"Sets an attribute to a specific value.\n\n        Args:\n            attribute: name of the attribute.\n            value: new value of the attribute.\n\n        Returns:\n            A new instance of the updated object.\n        \"\"\"\n        return eqx.tree_at(lambda s: s.__getattribute__(attribute), self, value)\n\n    def bulk_set(self, attr_dict):\n        \"\"\"Sets multiples attributes at once.\n\n        Args:\n            attr_dict: dictionary where keys are attribute names and values are\n                attributes values to be set.\n\n        Returns:\n            A new instance of the updated object.\n        \"\"\"\n\n        def _f(module):\n            return [module.__getattribute__(key) for key in attr_dict.keys()]\n\n        return eqx.tree_at(_f, self, attr_dict.values())\n</code></pre>"},{"location":"api/core/#somap.core.AbstractSom.__call__","title":"<code>__call__(input)</code>","text":"<p>Makes a single iteration.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>InputData</code> <p>Data array for the given SOM models.</p> required <p>Returns:</p> Type Description <p>A tuple with the new SOM model and the auxilary data.</p> Source code in <code>src/somap/core.py</code> <pre><code>def __call__(self, input: InputData):\n    \"\"\"Makes a single iteration.\n\n    Args:\n        input: Data array for the given SOM models.\n\n    Returns:\n        A tuple with the new SOM model and the auxilary data.\n    \"\"\"\n    input_bu_v = input[\"bu_v\"].reshape(self.in_size)\n    w_bu = self.w_bu.reshape((self.shape) + (self.in_size,))\n\n    # Compute distances over the 2D grid\n    f_dist = jax.vmap(\n        jax.vmap(self.algo.f_dist, in_axes=(0, None)), in_axes=(0, None)\n    )\n    dist = f_dist(w_bu, input_bu_v)\n\n    # Find the coordinates of the node with the minimal distance\n    x, y = jnp.unravel_index(jnp.argmin(dist), dist.shape)\n    winner = jnp.array([x, y])\n\n    if self.metrics:\n        # Find the second winner (replace the winner by a high value,\n        # then compute the `argmin` which is faster than a whole `argsort`)\n        x2, y2 = jnp.unravel_index(\n            jnp.argmin(dist.at[x, y].set(dist.max())), dist.shape\n        )\n\n    # Compute the neighbourhood 2D grid values\n    d = distance_map(self.shape, winner, self.topography, self.borderless)\n    nbh = self.algo.f_nbh(d, self.t, dist[x, y])\n\n    # Compute the learning rate for the 2D grid\n    lr = self.algo.f_lr(self.t, dist)\n\n    # Update model parameters\n    new_self = self.bulk_set(\n        {\n            \"w_bu\": self.algo.f_update(lr, nbh, input_bu_v, w_bu).reshape(\n                (self.shape + self.input_shape)\n            ),\n            \"i_act_nb\": self.i_act_nb.at[x, y].set((1 + self.i_act_nb[x, y])),\n            \"t\": self.t + 1,\n            \"winner\": winner,\n        }\n    )\n\n    aux = {}\n    if self.metrics:\n        aux[\"metrics\"] = {\n            \"quantization_error\": dist[x, y],\n            \"topographic_error\": d[x2, y2],\n        }\n    if self.debug:\n        aux[\"debug\"] = {\n            \"dist\": dist,\n            \"nbh\": nbh,\n            \"lr\": lr,\n        }\n\n    return new_self, aux\n</code></pre>"},{"location":"api/core/#somap.core.AbstractSom.__init__","title":"<code>__init__(shape, topography, borderless, input_shape, params, metrics=True, debug=False, key=jax.random.PRNGKey(0))</code>","text":"<p>Creates a SOM models.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <p>Shape of the 2D map.</p> required <code>topography</code> <p>Topography of the 2D map. Either 'square' for a square grid or 'hex' for hexagonal grid.</p> required <code>borderless</code> <p>Toroidal topography if True, meaning that the top (resp. left) border meets the bottom (resp. right) border.</p> required <code>input_shape</code> <p>Shape of the input data.</p> required <code>params</code> <p>Parameters of the SOM (depends on the SOM flavor).</p> required <code>metrics</code> <p>If True, returns quantization and topographic errors as auxilary data.</p> <code>True</code> <code>debug</code> <p>If True, returns debug data as auxilary data.</p> <code>False</code> <code>key</code> <code>PRNGKeyArray</code> <p>JAX random key used during map initialization.</p> <code>PRNGKey(0)</code> Source code in <code>src/somap/core.py</code> <pre><code>def __init__(\n    self,\n    shape,\n    topography,\n    borderless,\n    input_shape,\n    params,\n    metrics=True,\n    debug=False,\n    key: PRNGKeyArray = jax.random.PRNGKey(0),\n):\n    \"\"\"Creates a SOM models.\n\n    Args:\n        shape: Shape of the 2D map.\n        topography: Topography of the 2D map. Either 'square' for a square grid\n            or 'hex' for hexagonal grid.\n        borderless: Toroidal topography if True, meaning that the top (resp. left)\n            border meets the bottom (resp. right) border.\n        input_shape: Shape of the input data.\n        params: Parameters of the SOM (depends on the SOM flavor).\n        metrics: If True, returns quantization and topographic errors as auxilary\n            data.\n        debug: If True, returns debug data as auxilary data.\n        key: JAX random key used during map initialization.\n    \"\"\"\n    self.shape = shape\n    self.topography = topography\n    self.borderless = borderless\n    self.input_shape = input_shape\n    self.params = params\n    self.metrics = metrics\n    self.debug = debug\n\n    self.in_size = int(np.prod(self.input_shape))\n    self.t = jnp.array(0, dtype=jnp.int32)\n    self.w_bu = jax.random.uniform(\n        key, (self.shape + self.input_shape), dtype=jnp.float32\n    )\n    self.i_act_nb = jnp.zeros(self.shape, dtype=jnp.int32)\n    self.algo = self.generate_algo(params)\n    self.winner = jnp.zeros((2,), dtype=jnp.int32)\n</code></pre>"},{"location":"api/core/#somap.core.AbstractSom.bulk_set","title":"<code>bulk_set(attr_dict)</code>","text":"<p>Sets multiples attributes at once.</p> <p>Parameters:</p> Name Type Description Default <code>attr_dict</code> <p>dictionary where keys are attribute names and values are attributes values to be set.</p> required <p>Returns:</p> Type Description <p>A new instance of the updated object.</p> Source code in <code>src/somap/core.py</code> <pre><code>def bulk_set(self, attr_dict):\n    \"\"\"Sets multiples attributes at once.\n\n    Args:\n        attr_dict: dictionary where keys are attribute names and values are\n            attributes values to be set.\n\n    Returns:\n        A new instance of the updated object.\n    \"\"\"\n\n    def _f(module):\n        return [module.__getattribute__(key) for key in attr_dict.keys()]\n\n    return eqx.tree_at(_f, self, attr_dict.values())\n</code></pre>"},{"location":"api/core/#somap.core.AbstractSom.generate_algo","title":"<code>generate_algo(params)</code>","text":"<p>Converts specific SOM parameters into generic SOM functions.</p> Source code in <code>src/somap/core.py</code> <pre><code>@abstractstaticmethod\ndef generate_algo(params: AbstractSomParams) -&gt; SomAlgo:\n    \"\"\"Converts specific SOM parameters into generic SOM functions.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/core/#somap.core.AbstractSom.set","title":"<code>set(attribute, value)</code>","text":"<p>Sets an attribute to a specific value.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>name of the attribute.</p> required <code>value</code> <p>new value of the attribute.</p> required <p>Returns:</p> Type Description <p>A new instance of the updated object.</p> Source code in <code>src/somap/core.py</code> <pre><code>def set(self, attribute: str, value):\n    \"\"\"Sets an attribute to a specific value.\n\n    Args:\n        attribute: name of the attribute.\n        value: new value of the attribute.\n\n    Returns:\n        A new instance of the updated object.\n    \"\"\"\n    return eqx.tree_at(lambda s: s.__getattribute__(attribute), self, value)\n</code></pre>"},{"location":"api/core/#somap.core.AbstractSomParams","title":"<code>AbstractSomParams</code>","text":"<p>             Bases: <code>Module</code></p> <p>Abstract base class for SOM parameters.</p> Source code in <code>src/somap/core.py</code> <pre><code>class AbstractSomParams(eqx.Module):\n    \"\"\"Abstract base class for SOM parameters.\"\"\"\n</code></pre>"},{"location":"api/core/#somap.core.InputData","title":"<code>InputData</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Structure of the input data.</p> Note <p>Classical SOMs only have the 'bu_v' bottum-up input value. Other inputs allow to create more complex SOMs receiving top-down and lateral inputs with a mask.</p> Note bis <p>TypedDict instead of dataclass to facilitate future modifications.</p> Source code in <code>src/somap/core.py</code> <pre><code>class InputData(TypedDict):\n    \"\"\"Structure of the input data.\n\n    Note:\n        Classical SOMs only have the 'bu_v' bottum-up input value.\n        Other inputs allow to create more complex SOMs receiving top-down and lateral\n        inputs with a mask.\n\n    Note bis:\n        TypedDict instead of dataclass to facilitate future modifications.\n    \"\"\"\n\n    bu_v: Float[Array, \" x\"]  # Bottom-up input value\n    bu_m: Float[Array, \" x\"] | None  # Bottom-up input mask\n    td_v: Float[Array, \"2\"] | None  # Top-down input value\n    td_m: Float[Array, \"2\"] | None  # Top-down input mask\n    lat_v: Float[Array, \" y\"] | None  # Lateral input value\n    lat_m: Float[Array, \" y\"] | None  # Lateral input mask\n</code></pre>"},{"location":"api/core/#somap.core.SomAlgo","title":"<code>SomAlgo</code>","text":"<p>             Bases: <code>Module</code></p> <p>Generic SOM functions.</p> Source code in <code>src/somap/core.py</code> <pre><code>class SomAlgo(eqx.Module):\n    \"\"\"Generic SOM functions.\"\"\"\n\n    f_dist: Callable\n    f_nbh: Callable\n    f_lr: Callable\n    f_update: Callable\n</code></pre>"},{"location":"api/core/#somap.core.make_step","title":"<code>make_step(model, input)</code>","text":"<p>Makes a single iteration.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>AbstractSom</code> <p>SOM model.</p> required <code>input</code> <code>InputData</code> <p>Data array for the given SOM models.</p> required <p>Returns:</p> Type Description <p>A tuple with the new SOM model and the auxilary data.</p> Source code in <code>src/somap/core.py</code> <pre><code>@eqx.filter_jit\ndef make_step(model: AbstractSom, input: InputData):\n    \"\"\"Makes a single iteration.\n\n    Args:\n        model: SOM model.\n        input: Data array for the given SOM models.\n\n    Returns:\n        A tuple with the new SOM model and the auxilary data.\n    \"\"\"\n    input = jax.tree_map(lambda x: jnp.asarray(x), input)\n    return model(input)\n</code></pre>"},{"location":"api/core/#somap.core.make_steps","title":"<code>make_steps(model, inputs)</code>","text":"<p>Makes multiple iterations at once.</p> <p>Uses the <code>jax.lax.scan()</code> function to optimize computations.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>AbstractSom</code> <p>SOM model.</p> required <code>inputs</code> <p>Batch data array for the given SOM models.</p> required <p>Returns:</p> Type Description <p>A tuple with the new SOM model and the auxilary data.</p> Source code in <code>src/somap/core.py</code> <pre><code>@eqx.filter_jit\ndef make_steps(model: AbstractSom, inputs):\n    \"\"\"Makes multiple iterations at once.\n\n    Uses the `jax.lax.scan()` function to optimize computations.\n\n    Args:\n        model: SOM model.\n        inputs: Batch data array for the given SOM models.\n\n    Returns:\n        A tuple with the new SOM model and the auxilary data.\n    \"\"\"\n    inputs = jax.tree_map(lambda x: jnp.asarray(x), inputs)\n    return filter_scan(make_step, model, inputs)\n</code></pre>"},{"location":"api/datasets/","title":"Datasets","text":"<p>Ready-to-use datasets.</p> <p>A set of toy datasets formated for <code>somap</code> Self-Organizing Maps.</p>"},{"location":"api/datasets/#somap.datasets.Digits","title":"<code>Digits</code>","text":"<p>             Bases: <code>SomDataset</code></p> <p>Kind of mini-MNIST.</p> <p>~2k grayscale 8x8 images of digits from 0 to 9.</p> Source code in <code>src/somap/datasets/mnist.py</code> <pre><code>class Digits(SomDataset):\n    \"\"\"Kind of mini-MNIST.\n\n    ~2k grayscale 8x8 images of digits from 0 to 9.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Loads the mini-MNIST dataset from scikit-learn.\"\"\"\n\n        def _load_func():\n            dataset = load_dataset(\"sklearn-docs/digits\", header=None)\n            return np.asarray(dataset[\"train\"].data).T[:, :64].reshape(-1, 8, 8) / 16.0\n\n        self.data = load_data_with_caching(\"digits.npy\", _load_func)\n        self.nb = self.data.shape[0]\n        self.shape = self.data.shape[1:]\n</code></pre>"},{"location":"api/datasets/#somap.datasets.Digits.__init__","title":"<code>__init__()</code>","text":"<p>Loads the mini-MNIST dataset from scikit-learn.</p> Source code in <code>src/somap/datasets/mnist.py</code> <pre><code>def __init__(self):\n    \"\"\"Loads the mini-MNIST dataset from scikit-learn.\"\"\"\n\n    def _load_func():\n        dataset = load_dataset(\"sklearn-docs/digits\", header=None)\n        return np.asarray(dataset[\"train\"].data).T[:, :64].reshape(-1, 8, 8) / 16.0\n\n    self.data = load_data_with_caching(\"digits.npy\", _load_func)\n    self.nb = self.data.shape[0]\n    self.shape = self.data.shape[1:]\n</code></pre>"},{"location":"api/datasets/#somap.datasets.MNIST","title":"<code>MNIST</code>","text":"<p>             Bases: <code>SomDataset</code></p> <p>Classic MNIST.</p> <p>60k grayscale 28x28 images of digits from 0 to 9.</p> Source code in <code>src/somap/datasets/mnist.py</code> <pre><code>class MNIST(SomDataset):\n    \"\"\"Classic MNIST.\n\n    60k grayscale 28x28 images of digits from 0 to 9.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Loads the classic MNIST dataset.\"\"\"\n\n        def _load_func():\n            dataset = load_dataset(\"mnist\")\n            return np.asarray(dataset[\"train\"][\"image\"]) / 255.0\n\n        self.data = load_data_with_caching(\"mnist.npy\", _load_func)\n        self.nb = self.data.shape[0]\n        self.shape = self.data.shape[1:]\n</code></pre>"},{"location":"api/datasets/#somap.datasets.MNIST.__init__","title":"<code>__init__()</code>","text":"<p>Loads the classic MNIST dataset.</p> Source code in <code>src/somap/datasets/mnist.py</code> <pre><code>def __init__(self):\n    \"\"\"Loads the classic MNIST dataset.\"\"\"\n\n    def _load_func():\n        dataset = load_dataset(\"mnist\")\n        return np.asarray(dataset[\"train\"][\"image\"]) / 255.0\n\n    self.data = load_data_with_caching(\"mnist.npy\", _load_func)\n    self.nb = self.data.shape[0]\n    self.shape = self.data.shape[1:]\n</code></pre>"},{"location":"api/distance/","title":"Distance","text":"<p>Catalog of distance functions.</p> <p><code>dist</code> means distance <code>wdist</code> means weighted distance</p> <p>All distance functions are defined for comparison between 2 1D vectors.</p>"},{"location":"api/distance/#somap.distance.AbstractDist","title":"<code>AbstractDist</code>","text":"<p>             Bases: <code>Module</code></p> <p>Ensures that all distance functions have the same signatures.</p> Source code in <code>src/somap/distance.py</code> <pre><code>class AbstractDist(eqx.Module):\n    \"\"\"Ensures that all distance functions have the same signatures.\"\"\"\n\n    @abstractmethod\n    def __call__(\n        self, a: Float[Array, \" n\"], b: Float[Array, \" n\"]\n    ) -&gt; Float[Array, \"\"]:\n        \"\"\"SOM distance function.\n\n        Args:\n            a: 1D array.\n            b: 1D array.\n\n        Returns:\n            The distance as a scalar.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/distance/#somap.distance.AbstractDist.__call__","title":"<code>__call__(a, b)</code>  <code>abstractmethod</code>","text":"<p>SOM distance function.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Float[Array, ' n']</code> <p>1D array.</p> required <code>b</code> <code>Float[Array, ' n']</code> <p>1D array.</p> required <p>Returns:</p> Type Description <code>Float[Array, '']</code> <p>The distance as a scalar.</p> Source code in <code>src/somap/distance.py</code> <pre><code>@abstractmethod\ndef __call__(\n    self, a: Float[Array, \" n\"], b: Float[Array, \" n\"]\n) -&gt; Float[Array, \"\"]:\n    \"\"\"SOM distance function.\n\n    Args:\n        a: 1D array.\n        b: 1D array.\n\n    Returns:\n        The distance as a scalar.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/distance/#somap.distance.CyclicEuclidianDist","title":"<code>CyclicEuclidianDist</code>","text":"<p>             Bases: <code>AbstractDist</code></p> <p>Cyclic euclidian distance function.</p> Source code in <code>src/somap/distance.py</code> <pre><code>@experimental_warning\nclass CyclicEuclidianDist(AbstractDist):\n    \"\"\"Cyclic euclidian distance function.\"\"\"\n\n    def __call__(\n        self, a: Float[Array, \" n\"], b: Float[Array, \" n\"]\n    ) -&gt; Float[Array, \"\"]:\n        \"\"\"Returns a cyclic euclidian distance where 0 and 1 are equals.\n\n        More optimized than the `arccos(cos())` based cyclic distance.\n        Takes advantage of data type's limits.\n        \"\"\"\n        a = (a * 255).astype(jnp.uint8)\n        b = (b * 255).astype(jnp.uint8)\n        diff = (a - b).astype(jnp.int8)\n        return (jnp.linalg.norm(diff) / 128.0).mean()\n</code></pre>"},{"location":"api/distance/#somap.distance.CyclicEuclidianDist.__call__","title":"<code>__call__(a, b)</code>","text":"<p>Returns a cyclic euclidian distance where 0 and 1 are equals.</p> <p>More optimized than the <code>arccos(cos())</code> based cyclic distance. Takes advantage of data type's limits.</p> Source code in <code>src/somap/distance.py</code> <pre><code>def __call__(\n    self, a: Float[Array, \" n\"], b: Float[Array, \" n\"]\n) -&gt; Float[Array, \"\"]:\n    \"\"\"Returns a cyclic euclidian distance where 0 and 1 are equals.\n\n    More optimized than the `arccos(cos())` based cyclic distance.\n    Takes advantage of data type's limits.\n    \"\"\"\n    a = (a * 255).astype(jnp.uint8)\n    b = (b * 255).astype(jnp.uint8)\n    diff = (a - b).astype(jnp.int8)\n    return (jnp.linalg.norm(diff) / 128.0).mean()\n</code></pre>"},{"location":"api/distance/#somap.distance.EuclidianDist","title":"<code>EuclidianDist</code>","text":"<p>             Bases: <code>AbstractDist</code></p> <p>Euclidian distance function.</p> Source code in <code>src/somap/distance.py</code> <pre><code>class EuclidianDist(AbstractDist):\n    \"\"\"Euclidian distance function.\"\"\"\n\n    def __call__(\n        self, a: Float[Array, \" n\"], b: Float[Array, \" n\"]\n    ) -&gt; Float[Array, \"\"]:\n        \"\"\"Computes the euclidian norm.\"\"\"\n        return jnp.linalg.norm(a - b).mean()\n</code></pre>"},{"location":"api/distance/#somap.distance.EuclidianDist.__call__","title":"<code>__call__(a, b)</code>","text":"<p>Computes the euclidian norm.</p> Source code in <code>src/somap/distance.py</code> <pre><code>def __call__(\n    self, a: Float[Array, \" n\"], b: Float[Array, \" n\"]\n) -&gt; Float[Array, \"\"]:\n    \"\"\"Computes the euclidian norm.\"\"\"\n    return jnp.linalg.norm(a - b).mean()\n</code></pre>"},{"location":"api/distance/#somap.distance.dist_cim","title":"<code>dist_cim(v1, v2, sigma)</code>","text":"<p>The Correntropy Induced Metric (CIM) distance.</p> <p>It is based on correntropy which is a generalized correlation. It computes the distance between two vectors without suffering from the curse of dimensionality like the Euclidian distance thanks to a kernel function. The chosen kernel is a Gaussian function (parameterised by 'sigma'). For large sigma, the CIM distance tends to the L2 metric. For very small sigma, the CIM distance tends to the L0 norm.</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <p>first vector to be compared</p> required <code>v2</code> <p>second vector to be compared</p> required <code>sigma</code> <p>kernel bandwidth</p> required <p>Returns:</p> Type Description <p>A scalar value between 0 and 1 corresponding to the similarity between v1 and v2</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>incompatible shapes of v1 and v2</p> Source code in <code>src/somap/distance.py</code> <pre><code>@experimental_warning\ndef dist_cim(v1, v2, sigma):\n    \"\"\"The Correntropy Induced Metric (CIM) distance.\n\n    It is based on correntropy which is a generalized correlation.\n    It computes the distance between two vectors without suffering from the curse of\n    dimensionality like the Euclidian distance thanks to a kernel function.\n    The chosen kernel is a Gaussian function (parameterised by 'sigma').\n    For large sigma, the CIM distance tends to the L2 metric.\n    For very small sigma, the CIM distance tends to the L0 norm.\n\n    Args:\n        v1: first vector to be compared\n        v2: second vector to be compared\n        sigma: kernel bandwidth\n\n    Returns:\n        A scalar value between 0 and 1 corresponding to the similarity between v1 and v2\n\n    Raises:\n        ValueError: incompatible shapes of v1 and v2\n    \"\"\"\n    if v1.ndim != 1 or v2.ndim != 1 or v1.shape != v2.shape:\n        raise ValueError(\"v1 and v2 should be 1-D vectors of the same length\")\n\n    x = v1 - v2\n\n    kernel = jnp.exp(-(x**2) / (2 * sigma**2))\n    correntropy = jnp.mean(kernel)\n\n    return jnp.sqrt(1 - correntropy)\n</code></pre>"},{"location":"api/distance/#somap.distance.wdist_l2","title":"<code>wdist_l2(a, b, w)</code>","text":"<p>Computes a weighted version of the euclidian norm.</p> Source code in <code>src/somap/distance.py</code> <pre><code>@experimental_warning\ndef wdist_l2(\n    a: Float[Array, \" n\"], b: Float[Array, \" n\"], w: Float[Array, \" n\"]\n) -&gt; Float[Array, \"\"]:\n    \"\"\"Computes a weighted version of the euclidian norm.\"\"\"\n    q = a - b\n    return jnp.sqrt((w * q * q).sum())\n</code></pre>"},{"location":"api/learning_rate/","title":"Learning rate","text":"<p>Catalog of learning rate functions.</p>"},{"location":"api/learning_rate/#somap.learning_rate.AbstractLr","title":"<code>AbstractLr</code>","text":"<p>             Bases: <code>Module</code></p> <p>Ensures that all learning rate functions have the same signatures.</p> Source code in <code>src/somap/learning_rate.py</code> <pre><code>class AbstractLr(eqx.Module):\n    \"\"\"Ensures that all learning rate functions have the same signatures.\"\"\"\n\n    @abstractmethod\n    def __call__(\n        self, t: Integer[Array, \"\"], distances: Float[Array, \"x y\"]\n    ) -&gt; Float[Array, \"\"] | Float[Array, \"x y\"]:\n        \"\"\"SOM learning rate function.\n\n        Args:\n            t: Current iteration.\n            distances: Distances between the prototype weights and the input data.\n\n        Returns:\n            A scalar ar 2D array containing the learning rate.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/learning_rate/#somap.learning_rate.AbstractLr.__call__","title":"<code>__call__(t, distances)</code>  <code>abstractmethod</code>","text":"<p>SOM learning rate function.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Integer[Array, '']</code> <p>Current iteration.</p> required <code>distances</code> <code>Float[Array, 'x y']</code> <p>Distances between the prototype weights and the input data.</p> required <p>Returns:</p> Type Description <code>Float[Array, ''] | Float[Array, 'x y']</code> <p>A scalar ar 2D array containing the learning rate.</p> Source code in <code>src/somap/learning_rate.py</code> <pre><code>@abstractmethod\ndef __call__(\n    self, t: Integer[Array, \"\"], distances: Float[Array, \"x y\"]\n) -&gt; Float[Array, \"\"] | Float[Array, \"x y\"]:\n    \"\"\"SOM learning rate function.\n\n    Args:\n        t: Current iteration.\n        distances: Distances between the prototype weights and the input data.\n\n    Returns:\n        A scalar ar 2D array containing the learning rate.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/learning_rate/#somap.learning_rate.ConstantLr","title":"<code>ConstantLr</code>","text":"<p>             Bases: <code>AbstractLr</code></p> <p>Basic SOM learning rate function.</p> Source code in <code>src/somap/learning_rate.py</code> <pre><code>class ConstantLr(AbstractLr):\n    \"\"\"Basic SOM learning rate function.\"\"\"\n\n    alpha: float | Float[Array, \"...\"] = 0.01\n\n    def __call__(self, _, __) -&gt; Float[Array, \"\"]:\n        \"\"\"Returns the static SOM learning rate.\"\"\"\n        return jnp.array(self.alpha)\n</code></pre>"},{"location":"api/learning_rate/#somap.learning_rate.ConstantLr.__call__","title":"<code>__call__(_, __)</code>","text":"<p>Returns the static SOM learning rate.</p> Source code in <code>src/somap/learning_rate.py</code> <pre><code>def __call__(self, _, __) -&gt; Float[Array, \"\"]:\n    \"\"\"Returns the static SOM learning rate.\"\"\"\n    return jnp.array(self.alpha)\n</code></pre>"},{"location":"api/learning_rate/#somap.learning_rate.DsomLr","title":"<code>DsomLr</code>","text":"<p>             Bases: <code>AbstractLr</code></p> <p>DSOM learning rate function.</p> Source code in <code>src/somap/learning_rate.py</code> <pre><code>class DsomLr(AbstractLr):\n    \"\"\"DSOM learning rate function.\"\"\"\n\n    alpha: float | Float[Array, \"...\"] = 0.001\n\n    def __call__(self, _, distances: Float[Array, \"x y\"]) -&gt; Float[Array, \"x y\"]:\n        \"\"\"Returns the DSOM learning rate.\"\"\"\n        return self.alpha * distances\n</code></pre>"},{"location":"api/learning_rate/#somap.learning_rate.DsomLr.__call__","title":"<code>__call__(_, distances)</code>","text":"<p>Returns the DSOM learning rate.</p> Source code in <code>src/somap/learning_rate.py</code> <pre><code>def __call__(self, _, distances: Float[Array, \"x y\"]) -&gt; Float[Array, \"x y\"]:\n    \"\"\"Returns the DSOM learning rate.\"\"\"\n    return self.alpha * distances\n</code></pre>"},{"location":"api/learning_rate/#somap.learning_rate.KsomLr","title":"<code>KsomLr</code>","text":"<p>             Bases: <code>AbstractLr</code></p> <p>Kohonen SOM learning rate function.</p> Source code in <code>src/somap/learning_rate.py</code> <pre><code>class KsomLr(AbstractLr):\n    \"\"\"Kohonen SOM learning rate function.\"\"\"\n\n    t_f: int | Integer[Array, \"...\"] = 100000\n    alpha_i: float | Float[Array, \"...\"] = 0.01\n    alpha_f: float | Float[Array, \"...\"] = 0.001\n\n    def __call__(self, t: Integer[Array, \"\"], _) -&gt; Float[Array, \"\"]:\n        \"\"\"Returns the Kohonen SOM learning rate.\"\"\"\n        return self.alpha_i * (self.alpha_f / self.alpha_i) ** (t / self.t_f)\n</code></pre>"},{"location":"api/learning_rate/#somap.learning_rate.KsomLr.__call__","title":"<code>__call__(t, _)</code>","text":"<p>Returns the Kohonen SOM learning rate.</p> Source code in <code>src/somap/learning_rate.py</code> <pre><code>def __call__(self, t: Integer[Array, \"\"], _) -&gt; Float[Array, \"\"]:\n    \"\"\"Returns the Kohonen SOM learning rate.\"\"\"\n    return self.alpha_i * (self.alpha_f / self.alpha_i) ** (t / self.t_f)\n</code></pre>"},{"location":"api/neighborhood/","title":"Neighborhood","text":"<p>Catalog of neighborhood functions.</p> <p>Neighborhood functions are defined as <code>equinox.Module</code> parametrized functions</p>"},{"location":"api/neighborhood/#somap.neighborhood.AbstractNbh","title":"<code>AbstractNbh</code>","text":"<p>             Bases: <code>Module</code></p> <p>Ensures that all neighborhood functions have the same signatures.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>class AbstractNbh(eqx.Module):\n    \"\"\"Ensures that all neighborhood functions have the same signatures.\"\"\"\n\n    @abstractmethod\n    def __call__(\n        self,\n        distance_map: Float[Array, \"x y\"],\n        t: Integer[Array, \"\"],\n        quantization_error: Float[Array, \"\"],\n    ) -&gt; Float[Array, \"x y\"]:\n        \"\"\"SOM Neighborhood function.\n\n        Args:\n            distance_map: Distance of each grid elements from the winning element.\n            t: Current iteration.\n            quantization_error: The computed difference between the winner prototype\n                and the input.\n\n        Returns:\n            The neighborhood distance.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/neighborhood/#somap.neighborhood.AbstractNbh.__call__","title":"<code>__call__(distance_map, t, quantization_error)</code>  <code>abstractmethod</code>","text":"<p>SOM Neighborhood function.</p> <p>Parameters:</p> Name Type Description Default <code>distance_map</code> <code>Float[Array, 'x y']</code> <p>Distance of each grid elements from the winning element.</p> required <code>t</code> <code>Integer[Array, '']</code> <p>Current iteration.</p> required <code>quantization_error</code> <code>Float[Array, '']</code> <p>The computed difference between the winner prototype and the input.</p> required <p>Returns:</p> Type Description <code>Float[Array, 'x y']</code> <p>The neighborhood distance.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>@abstractmethod\ndef __call__(\n    self,\n    distance_map: Float[Array, \"x y\"],\n    t: Integer[Array, \"\"],\n    quantization_error: Float[Array, \"\"],\n) -&gt; Float[Array, \"x y\"]:\n    \"\"\"SOM Neighborhood function.\n\n    Args:\n        distance_map: Distance of each grid elements from the winning element.\n        t: Current iteration.\n        quantization_error: The computed difference between the winner prototype\n            and the input.\n\n    Returns:\n        The neighborhood distance.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/neighborhood/#somap.neighborhood.DsomNbh","title":"<code>DsomNbh</code>","text":"<p>             Bases: <code>AbstractNbh</code></p> <p>Dynamic Kohonen neighborhood function.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>class DsomNbh(AbstractNbh):\n    \"\"\"Dynamic Kohonen neighborhood function.\"\"\"\n\n    plasticity: float | Float[Array, \"...\"] = 0.1\n\n    def __call__(\n        self, distance_map: Float[Array, \"x y\"], _, quantization_error: Float[Array, \"\"]\n    ) -&gt; Float[Array, \"x y\"]:\n        \"\"\"Computes the Dynamic SOM neighboring value of each grid element.\n\n        See:\n            Nicolas P. Rougier, Yann Boniface. Dynamic Self-Organising Map.\n            Neurocomputing, Elsevier, 2011, 74 (11), pp.1840-1847.\n            ff10.1016/j.neucom.2010.06.034ff. ffinria-00495827\n\n        Args:\n            self:\n                self.plasticity: Dynamic value to compute the neighbourhood distance.\n            distance_map: Distance of each element from the winner element.\n            _: Not used\n            quantization_error: The computed difference between the winner prototype\n                and the input.\n\n        Returns:\n            The neighborhood distance, as calculated in the article.\n        \"\"\"\n        return jnp.exp(\n            -(distance_map**2) / (self.plasticity**2 * quantization_error**2)\n        )\n</code></pre>"},{"location":"api/neighborhood/#somap.neighborhood.DsomNbh.__call__","title":"<code>__call__(distance_map, _, quantization_error)</code>","text":"<p>Computes the Dynamic SOM neighboring value of each grid element.</p> See <p>Nicolas P. Rougier, Yann Boniface. Dynamic Self-Organising Map. Neurocomputing, Elsevier, 2011, 74 (11), pp.1840-1847. ff10.1016/j.neucom.2010.06.034ff. ffinria-00495827</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>self.plasticity: Dynamic value to compute the neighbourhood distance.</p> required <code>distance_map</code> <code>Float[Array, 'x y']</code> <p>Distance of each element from the winner element.</p> required <code>_</code> <p>Not used</p> required <code>quantization_error</code> <code>Float[Array, '']</code> <p>The computed difference between the winner prototype and the input.</p> required <p>Returns:</p> Type Description <code>Float[Array, 'x y']</code> <p>The neighborhood distance, as calculated in the article.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>def __call__(\n    self, distance_map: Float[Array, \"x y\"], _, quantization_error: Float[Array, \"\"]\n) -&gt; Float[Array, \"x y\"]:\n    \"\"\"Computes the Dynamic SOM neighboring value of each grid element.\n\n    See:\n        Nicolas P. Rougier, Yann Boniface. Dynamic Self-Organising Map.\n        Neurocomputing, Elsevier, 2011, 74 (11), pp.1840-1847.\n        ff10.1016/j.neucom.2010.06.034ff. ffinria-00495827\n\n    Args:\n        self:\n            self.plasticity: Dynamic value to compute the neighbourhood distance.\n        distance_map: Distance of each element from the winner element.\n        _: Not used\n        quantization_error: The computed difference between the winner prototype\n            and the input.\n\n    Returns:\n        The neighborhood distance, as calculated in the article.\n    \"\"\"\n    return jnp.exp(\n        -(distance_map**2) / (self.plasticity**2 * quantization_error**2)\n    )\n</code></pre>"},{"location":"api/neighborhood/#somap.neighborhood.GaussianNbh","title":"<code>GaussianNbh</code>","text":"<p>             Bases: <code>AbstractNbh</code></p> <p>Exponentially decreasing neighborhood function.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>class GaussianNbh(AbstractNbh):\n    \"\"\"Exponentially decreasing neighborhood function.\"\"\"\n\n    sigma: float | Float[Array, \"...\"] = 0.1\n\n    def __call__(self, distance_map: Float[Array, \"x y\"], t, __) -&gt; Float[Array, \"x y\"]:\n        \"\"\"Return the Kohonen time-independent neighboring value of each element.\n\n        Args:\n            self: Module's parameters\n                self.sigma: Neighbourhood distance.\n            distance_map: Distance of each element from the winner element.\n            t: Not used\n            __: Not used\n\n        Returns:\n            The kohonen neighborhood distance.\n        \"\"\"\n        # Surprisingly, `(t+1)/(t+1)` speeds up the jitted function on CPU with JAX.\n        sigma = self.sigma * (t + 1) / (t + 1)\n        return jnp.exp(-(distance_map**2) / (2 * sigma**2))\n</code></pre>"},{"location":"api/neighborhood/#somap.neighborhood.GaussianNbh.__call__","title":"<code>__call__(distance_map, t, __)</code>","text":"<p>Return the Kohonen time-independent neighboring value of each element.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Module's parameters self.sigma: Neighbourhood distance.</p> required <code>distance_map</code> <code>Float[Array, 'x y']</code> <p>Distance of each element from the winner element.</p> required <code>t</code> <p>Not used</p> required <code>__</code> <p>Not used</p> required <p>Returns:</p> Type Description <code>Float[Array, 'x y']</code> <p>The kohonen neighborhood distance.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>def __call__(self, distance_map: Float[Array, \"x y\"], t, __) -&gt; Float[Array, \"x y\"]:\n    \"\"\"Return the Kohonen time-independent neighboring value of each element.\n\n    Args:\n        self: Module's parameters\n            self.sigma: Neighbourhood distance.\n        distance_map: Distance of each element from the winner element.\n        t: Not used\n        __: Not used\n\n    Returns:\n        The kohonen neighborhood distance.\n    \"\"\"\n    # Surprisingly, `(t+1)/(t+1)` speeds up the jitted function on CPU with JAX.\n    sigma = self.sigma * (t + 1) / (t + 1)\n    return jnp.exp(-(distance_map**2) / (2 * sigma**2))\n</code></pre>"},{"location":"api/neighborhood/#somap.neighborhood.KsomNbh","title":"<code>KsomNbh</code>","text":"<p>             Bases: <code>AbstractNbh</code></p> <p>Kohonen neighborhood function.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>class KsomNbh(AbstractNbh):\n    \"\"\"Kohonen neighborhood function.\"\"\"\n\n    t_f: int | Integer[Array, \"...\"] = 100000\n    sigma_i: float | Float[Array, \"...\"] = 1.0\n    sigma_f: float | Float[Array, \"...\"] = 0.01\n\n    def __call__(\n        self, distance_map: Float[Array, \"x y\"], t: Integer[Array, \"\"], _\n    ) -&gt; Float[Array, \"x y\"]:\n        \"\"\"Returns the Kohonen neighboring value of each element.\n\n        Args:\n            self: Module's parameters\n                self.t_f: Aimed iteration.\n                self.sigma_i: Current neighborhood distance.\n                self.sigma_f: Aimed neighborhood distance.\n            distance_map: Distance of each grid elements from the winning element.\n            t: Current iteration.\n            _: Not used\n\n        Returns:\n            The kohonen neighborhood distance.\n        \"\"\"\n        sigma = self.sigma_i * (self.sigma_f / self.sigma_i) ** (t / self.t_f)\n        return jnp.exp(-(distance_map**2) / (2 * sigma**2))\n</code></pre>"},{"location":"api/neighborhood/#somap.neighborhood.KsomNbh.__call__","title":"<code>__call__(distance_map, t, _)</code>","text":"<p>Returns the Kohonen neighboring value of each element.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Module's parameters self.t_f: Aimed iteration. self.sigma_i: Current neighborhood distance. self.sigma_f: Aimed neighborhood distance.</p> required <code>distance_map</code> <code>Float[Array, 'x y']</code> <p>Distance of each grid elements from the winning element.</p> required <code>t</code> <code>Integer[Array, '']</code> <p>Current iteration.</p> required <code>_</code> <p>Not used</p> required <p>Returns:</p> Type Description <code>Float[Array, 'x y']</code> <p>The kohonen neighborhood distance.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>def __call__(\n    self, distance_map: Float[Array, \"x y\"], t: Integer[Array, \"\"], _\n) -&gt; Float[Array, \"x y\"]:\n    \"\"\"Returns the Kohonen neighboring value of each element.\n\n    Args:\n        self: Module's parameters\n            self.t_f: Aimed iteration.\n            self.sigma_i: Current neighborhood distance.\n            self.sigma_f: Aimed neighborhood distance.\n        distance_map: Distance of each grid elements from the winning element.\n        t: Current iteration.\n        _: Not used\n\n    Returns:\n        The kohonen neighborhood distance.\n    \"\"\"\n    sigma = self.sigma_i * (self.sigma_f / self.sigma_i) ** (t / self.t_f)\n    return jnp.exp(-(distance_map**2) / (2 * sigma**2))\n</code></pre>"},{"location":"api/neighborhood/#somap.neighborhood.MexicanHatNbh","title":"<code>MexicanHatNbh</code>","text":"<p>             Bases: <code>AbstractNbh</code></p> <p>Mexican Hat neighborhood function.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>class MexicanHatNbh(AbstractNbh):\n    \"\"\"Mexican Hat neighborhood function.\"\"\"\n\n    sigma: float | Float[Array, \"...\"] = 0.1\n\n    def __call__(self, distance_map: Float[Array, \"x y\"], _, __) -&gt; Float[Array, \"x y\"]:\n        \"\"\"Computes the Mexican Hat neighboring value of each grid element.\n\n        Args:\n            self:\n                self.sigma: Scale factor for the spread of the neighborhood.\n            distance_map: Distance of each element from the winner element.\n            _: Not used\n            __: Not used\n\n        Returns:\n            The Mexican Hat neighborhood distance.\n        \"\"\"\n        r2_norm = distance_map**2 / self.sigma**2\n        return (1 - 0.5 * r2_norm) * jnp.exp(-r2_norm / 2)\n</code></pre>"},{"location":"api/neighborhood/#somap.neighborhood.MexicanHatNbh.__call__","title":"<code>__call__(distance_map, _, __)</code>","text":"<p>Computes the Mexican Hat neighboring value of each grid element.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>self.sigma: Scale factor for the spread of the neighborhood.</p> required <code>distance_map</code> <code>Float[Array, 'x y']</code> <p>Distance of each element from the winner element.</p> required <code>_</code> <p>Not used</p> required <code>__</code> <p>Not used</p> required <p>Returns:</p> Type Description <code>Float[Array, 'x y']</code> <p>The Mexican Hat neighborhood distance.</p> Source code in <code>src/somap/neighborhood.py</code> <pre><code>def __call__(self, distance_map: Float[Array, \"x y\"], _, __) -&gt; Float[Array, \"x y\"]:\n    \"\"\"Computes the Mexican Hat neighboring value of each grid element.\n\n    Args:\n        self:\n            self.sigma: Scale factor for the spread of the neighborhood.\n        distance_map: Distance of each element from the winner element.\n        _: Not used\n        __: Not used\n\n    Returns:\n        The Mexican Hat neighborhood distance.\n    \"\"\"\n    r2_norm = distance_map**2 / self.sigma**2\n    return (1 - 0.5 * r2_norm) * jnp.exp(-r2_norm / 2)\n</code></pre>"},{"location":"api/plot/","title":"Plot","text":"<p>Plot functions for somap.Som objects.</p>"},{"location":"api/plot/#somap.plot.plot","title":"<code>plot(som, *args, **kwargs)</code>","text":"<p>Returns a graph/plot object of the SOM.</p> <p>Extra args depend on the chosen backend. See <code>.plot_backends.{name_of_backend}</code> for details.</p> <p>Parameters:</p> Name Type Description Default <code>som</code> <code>AbstractSom</code> <p>Self-Organizing Map as a Som object.</p> required <code>args</code> <p>Positional arguments passed to the <code>SomPlot</code> backend.</p> <code>()</code> <code>kwargs</code> <p>Keyword arguments passed to the <code>SomPlot</code> backend.</p> <code>{}</code> Source code in <code>src/somap/plot.py</code> <pre><code>def plot(som: AbstractSom, *args, **kwargs):\n    \"\"\"Returns a graph/plot object of the SOM.\n\n    Extra args depend on the chosen backend.\n    See `.plot_backends.{name_of_backend}` for details.\n\n    Args:\n        som: Self-Organizing Map as a Som object.\n        args: Positional arguments passed to the `SomPlot` backend.\n        kwargs: Keyword arguments passed to the `SomPlot` backend.\n    \"\"\"\n    backend = import_backend()\n    som_plot = backend.SomPlot(som, *args, **kwargs)\n    return som_plot.plot()\n</code></pre>"},{"location":"api/plot/#somap.plot.save_plot","title":"<code>save_plot(som, filename, *args, **kwargs)</code>","text":"<p>Saves a graph/plot image of the SOM.</p> <p>Parameters:</p> Name Type Description Default <code>som</code> <code>AbstractSom</code> <p>Self-Organizing Map as a Som object.</p> required <code>filename</code> <code>str | IO</code> <p>File in which to write the chart.</p> required <code>args</code> <p>Positional arguments passed to the <code>SomPlot</code> backend.</p> <code>()</code> <code>kwargs</code> <p>Keyword arguments passed to the <code>SomPlot</code> backend.</p> <code>{}</code> Source code in <code>src/somap/plot.py</code> <pre><code>def save_plot(som: AbstractSom, filename: str | IO, *args, **kwargs):\n    \"\"\"Saves a graph/plot image of the SOM.\n\n    Args:\n        som: Self-Organizing Map as a Som object.\n        filename: File in which to write the chart.\n        args: Positional arguments passed to the `SomPlot` backend.\n        kwargs: Keyword arguments passed to the `SomPlot` backend.\n    \"\"\"\n    backend = import_backend()\n    som_plot = backend.SomPlot(som, *args, **kwargs)\n    som_plot.save(filename)\n</code></pre>"},{"location":"api/plot_backends/","title":"Plot backends","text":""},{"location":"api/plot_backends/#base","title":"Base","text":"<p>Abstract base class for plot backends.</p>"},{"location":"api/plot_backends/#somap.plot_backends.base.AbstractSomPlot","title":"<code>AbstractSomPlot</code>","text":"<p>             Bases: <code>ABC</code></p> <p>SomPlot.</p> Source code in <code>src/somap/plot_backends/base.py</code> <pre><code>class AbstractSomPlot(ABC):\n    \"\"\"SomPlot.\"\"\"\n\n    @abstractmethod\n    def __init__(self, som, *, show_prototypes=True, show_activity=False, **kwargs):\n        \"\"\"Creates a SomPlot.\n\n        Args:\n            som: Self-Organizing Map as a Som object.\n            args: Positional arguments passed to the `SomPlot` backend.\n            show_prototypes: Show prototypes of each node as an image.\n            show_activity: Show activity value of each node as a color.\n            kwargs: Keyword arguments passed to the `SomPlot` backend.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def plot(self):\n        \"\"\"Returns the plot chart.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def save(self):\n        \"\"\"Saves the plot as an image.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.base.AbstractSomPlot.__init__","title":"<code>__init__(som, *, show_prototypes=True, show_activity=False, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Creates a SomPlot.</p> <p>Parameters:</p> Name Type Description Default <code>som</code> <p>Self-Organizing Map as a Som object.</p> required <code>args</code> <p>Positional arguments passed to the <code>SomPlot</code> backend.</p> required <code>show_prototypes</code> <p>Show prototypes of each node as an image.</p> <code>True</code> <code>show_activity</code> <p>Show activity value of each node as a color.</p> <code>False</code> <code>kwargs</code> <p>Keyword arguments passed to the <code>SomPlot</code> backend.</p> <code>{}</code> Source code in <code>src/somap/plot_backends/base.py</code> <pre><code>@abstractmethod\ndef __init__(self, som, *, show_prototypes=True, show_activity=False, **kwargs):\n    \"\"\"Creates a SomPlot.\n\n    Args:\n        som: Self-Organizing Map as a Som object.\n        args: Positional arguments passed to the `SomPlot` backend.\n        show_prototypes: Show prototypes of each node as an image.\n        show_activity: Show activity value of each node as a color.\n        kwargs: Keyword arguments passed to the `SomPlot` backend.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.base.AbstractSomPlot.plot","title":"<code>plot()</code>  <code>abstractmethod</code>","text":"<p>Returns the plot chart.</p> Source code in <code>src/somap/plot_backends/base.py</code> <pre><code>@abstractmethod\ndef plot(self):\n    \"\"\"Returns the plot chart.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.base.AbstractSomPlot.save","title":"<code>save()</code>  <code>abstractmethod</code>","text":"<p>Saves the plot as an image.</p> Source code in <code>src/somap/plot_backends/base.py</code> <pre><code>@abstractmethod\ndef save(self):\n    \"\"\"Saves the plot as an image.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/plot_backends/#altair","title":"Altair","text":"<p>Altair plot backends.</p>"},{"location":"api/plot_backends/#somap.plot_backends.altair.SomPlot","title":"<code>SomPlot</code>","text":"<p>             Bases: <code>AbstractSomPlot</code></p> <p>SomPlot.</p> Source code in <code>src/somap/plot_backends/altair.py</code> <pre><code>class SomPlot(AbstractSomPlot):\n    \"\"\"SomPlot.\"\"\"\n\n    def __init__(\n        self,\n        som: AbstractSom,\n        *,\n        show_prototypes=True,\n        show_activity=False,\n        **kwargs,\n    ):\n        \"\"\"Creates a SomPlot.\n\n        Args:\n            som: Self-Organizing Map as a Som object.\n            args: Positional arguments passed to the `SomPlot` backend.r.ravel()\n            show_prototypes: Show prototypes of each node as an image.\n            show_activity: Show activity value of each node as a color.\n            kwargs: Keyword arguments passed to the `SomPlot` backend.\n        \"\"\"\n        _images = som.w_bu.reshape(som.shape + som.input_shape)\n        _values = som.i_act_nb\n\n        kwargs1 = {k[4:]: v for k, v in kwargs.items() if k.startswith(\"img_\")}\n        kwargs2 = {k[4:]: v for k, v in kwargs.items() if k.startswith(\"plt_\")}\n\n        chart_data = _encode_plot_data(images=_images, values=_values, **kwargs1)\n        self.chart = plot(\n            chart_data,\n            som.shape,\n            som.topography,\n            images=show_prototypes,\n            values=show_activity,\n            **kwargs2,\n        )\n\n    def plot(self):\n        \"\"\"Returns the plot chart.\"\"\"\n        return self.chart\n\n    def save(self, filename: str | IO, *args, **kwargs):\n        \"\"\"Saves the plot as an image.\"\"\"\n        self.chart.save(filename)\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.altair.SomPlot.__init__","title":"<code>__init__(som, *, show_prototypes=True, show_activity=False, **kwargs)</code>","text":"<p>Creates a SomPlot.</p> <p>Parameters:</p> Name Type Description Default <code>som</code> <code>AbstractSom</code> <p>Self-Organizing Map as a Som object.</p> required <code>args</code> <p>Positional arguments passed to the <code>SomPlot</code> backend.r.ravel()</p> required <code>show_prototypes</code> <p>Show prototypes of each node as an image.</p> <code>True</code> <code>show_activity</code> <p>Show activity value of each node as a color.</p> <code>False</code> <code>kwargs</code> <p>Keyword arguments passed to the <code>SomPlot</code> backend.</p> <code>{}</code> Source code in <code>src/somap/plot_backends/altair.py</code> <pre><code>def __init__(\n    self,\n    som: AbstractSom,\n    *,\n    show_prototypes=True,\n    show_activity=False,\n    **kwargs,\n):\n    \"\"\"Creates a SomPlot.\n\n    Args:\n        som: Self-Organizing Map as a Som object.\n        args: Positional arguments passed to the `SomPlot` backend.r.ravel()\n        show_prototypes: Show prototypes of each node as an image.\n        show_activity: Show activity value of each node as a color.\n        kwargs: Keyword arguments passed to the `SomPlot` backend.\n    \"\"\"\n    _images = som.w_bu.reshape(som.shape + som.input_shape)\n    _values = som.i_act_nb\n\n    kwargs1 = {k[4:]: v for k, v in kwargs.items() if k.startswith(\"img_\")}\n    kwargs2 = {k[4:]: v for k, v in kwargs.items() if k.startswith(\"plt_\")}\n\n    chart_data = _encode_plot_data(images=_images, values=_values, **kwargs1)\n    self.chart = plot(\n        chart_data,\n        som.shape,\n        som.topography,\n        images=show_prototypes,\n        values=show_activity,\n        **kwargs2,\n    )\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.altair.SomPlot.plot","title":"<code>plot()</code>","text":"<p>Returns the plot chart.</p> Source code in <code>src/somap/plot_backends/altair.py</code> <pre><code>def plot(self):\n    \"\"\"Returns the plot chart.\"\"\"\n    return self.chart\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.altair.SomPlot.save","title":"<code>save(filename, *args, **kwargs)</code>","text":"<p>Saves the plot as an image.</p> Source code in <code>src/somap/plot_backends/altair.py</code> <pre><code>def save(self, filename: str | IO, *args, **kwargs):\n    \"\"\"Saves the plot as an image.\"\"\"\n    self.chart.save(filename)\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.altair.plot","title":"<code>plot(data, shape, topography, *, bin_size_scale=1.0, w_scale=1.0, h_scale=1.0, values=True, images=True, tooltip=True, color_scale=alt.Scale(scheme='lighttealblue'), color_legend=None, title=None)</code>","text":"<p>Return an Altair chart containing shape[0] * shape[1] hexagons.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>Pandas dataframe with the following columns: x: Horizontal coordinate in the hex grid. y: Vertical coordonates in the hex grid. values: one scalar value per hexagon (optional). images: one encoded image per hexagon (optional). image: one encoded image per hexagon (for tooltip) (optional). infos: one text value per hexagon(optional).</p> required <code>shape</code> <code>tuple[int, int]</code> <p>column and line numbers of the hex grid.</p> required <code>topography</code> <code>str</code> <p>Topography of the 2D map, either 'square' or 'hex'.</p> required <code>bin_size_scale</code> <code>float</code> <p>size of the hexagons.</p> <code>1.0</code> <code>w_scale</code> <code>float</code> <p>horizontal scaling factor (sometimes needed to go around rendering bugs of external libs).</p> <code>1.0</code> <code>h_scale</code> <code>float</code> <p>vertical scaling factor (sometimes needed to go around rendering bugs of external libs).</p> <code>1.0</code> <code>values</code> <code>bool</code> <p>if True, fill the hexagons with a color corresponding to data['values'].</p> <code>True</code> <code>images</code> <code>bool</code> <p>if True, show the image of all hexagon with an image corresponding to data['images'].</p> <code>True</code> <code>tooltip</code> <code>bool</code> <p>if True, show an interactive tooltip given detailed values of the selected hexagon</p> <code>True</code> <code>color_scale</code> <code>Scale</code> <p>color scale used if color is True. Continous scale from light blue to dark blue by default.</p> <code>Scale(scheme='lighttealblue')</code> <code>color_legend</code> <code>Legend | None</code> <p>arr color legend used if color is True. Dynamic legend by default. (set to 'None' to hide the legend).</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Title of the plot.</p> <code>None</code> <p>Returns:</p> Type Description <code>LayerChart</code> <p>The altair chart.</p> Source code in <code>src/somap/plot_backends/altair.py</code> <pre><code>def plot(\n    data: pd.DataFrame,\n    shape: tuple[int, int],\n    topography: str,\n    *,\n    bin_size_scale: float = 1.0,\n    w_scale: float = 1.0,\n    h_scale: float = 1.0,\n    values: bool = True,\n    images: bool = True,\n    tooltip: bool = True,\n    color_scale: alt.Scale = alt.Scale(scheme=\"lighttealblue\"),\n    color_legend: alt.Legend | None = None,\n    title: str | None = None,\n) -&gt; alt.LayerChart:\n    \"\"\"Return an Altair chart containing shape[0] * shape[1] hexagons.\n\n    Args:\n        data: Pandas dataframe with the following columns:\n            x: Horizontal coordinate in the hex grid.\n            y: Vertical coordonates in the hex grid.\n            values: one scalar value per hexagon (optional).\n            images: one encoded image per hexagon (optional).\n            image: one encoded image per hexagon (for tooltip) (optional).\n            infos: one text value per hexagon(optional).\n        shape: column and line numbers of the hex grid.\n        topography: Topography of the 2D map, either 'square' or 'hex'.\n        bin_size_scale: size of the hexagons.\n        w_scale: horizontal scaling factor (sometimes needed to go around rendering\n            bugs of external libs).\n        h_scale: vertical scaling factor (sometimes needed to go around rendering bugs\n            of external libs).\n        values: if True, fill the hexagons with a color corresponding to data['values'].\n        images: if True, show the image of all hexagon with an image corresponding to\n            data['images'].\n        tooltip: if True, show an interactive tooltip given detailed values of the\n            selected hexagon\n        color_scale: color scale used if color is True. Continous scale from light blue\n            to dark blue by default.\n        color_legend:arr color legend used if color is True. Dynamic legend by default.\n            (set to 'None' to hide the legend).\n        title: Title of the plot.\n\n    Returns:\n        The altair chart.\n    \"\"\"\n    if values and \"value\" not in data.columns:\n        raise ValueError(\n            \"Chart data must contain the 'values' field to fill colors. \\\n            If you don't want to fill colors, use the `color=False` argument\"\n        )\n\n    if images and \"image\" not in data.columns:\n        raise ValueError(\n            \"Chart data must contain the 'images' field to show images. \\\n            If you don't want to show images, use the `images=False` argument\"\n        )\n\n    x_nb, y_nb = shape\n\n    if topography == \"hex\":\n        marker_shape = \"M0,-2.3094L2,-1.1547 2,1.1547 0,2.3094 -2,1.1547 -2,-1.1547Z\"\n        bin_size = int(22 * bin_size_scale)\n        w_scale = 2 * w_scale\n        h_scale = 1.6 * h_scale\n    elif topography == \"square\":\n        marker_shape = \"M 1 -1 L 1 1 L -1 1 L -1 -1 Z\"\n        bin_size = int(40 * bin_size_scale)\n        w_scale = 0.9 * w_scale\n        h_scale = 0.9 * h_scale\n    else:\n        raise ValueError(\n            f\"Topography must be either 'square' or 'hex' (not {topography})\"\n        )\n\n    _axis = alt.Axis(title=\"\", labels=False, grid=False, tickOpacity=0, domainOpacity=0)\n\n    chart = (\n        alt.Chart(data)\n        .encode(\n            x=alt.X(\"x:Q\", axis=_axis),\n            y=alt.Y(\"y:Q\", axis=_axis),\n            stroke=alt.value(\"black\"),\n            strokeWidth=alt.value(0.2),\n        )\n        .properties(width=w_scale * bin_size * x_nb, height=h_scale * bin_size * y_nb)\n    )\n\n    if values:\n        chart = chart.encode(\n            fill=alt.Color(\"value:Q\", scale=color_scale, legend=color_legend)\n        )\n\n    if images:\n        chart = chart.encode(url=\"image\")\n\n    if tooltip:\n        chart = chart.encode(\n            tooltip=[\"x\", \"y\"]\n            + [\"image\"] * (\"image\" in data.columns)\n            + [\"value:Q\"] * (\"value\" in data.columns)\n        )\n\n    if topography == \"hex\":\n        chart = chart.encode(x=alt.X(\"xPos:Q\", axis=_axis))\n        chart = chart.transform_calculate(\n            xPos=\"(datum.x + 1 / 2 * ((datum.y + 1) % 2))\"\n        )\n\n    if title is not None:\n        chart = chart.properties(title=title)\n\n    c = alt.layer(\n        chart.mark_point(size=bin_size**2, shape=marker_shape),\n        chart.mark_image(width=25, height=25),\n    ).configure_view(strokeWidth=0)\n\n    return c\n</code></pre>"},{"location":"api/plot_backends/#array2image","title":"Array2image","text":"<p>Array2image plot backends.</p>"},{"location":"api/plot_backends/#somap.plot_backends.array2image.SomPlot","title":"<code>SomPlot</code>","text":"<p>             Bases: <code>AbstractSomPlot</code></p> <p>SomPlot.</p> Source code in <code>src/somap/plot_backends/array2image.py</code> <pre><code>class SomPlot(AbstractSomPlot):\n    \"\"\"SomPlot.\"\"\"\n\n    def __init__(\n        self,\n        som: AbstractSom,\n        *,\n        show_prototypes=True,\n        show_activity=False,\n        **kwargs,\n    ):\n        \"\"\"Creates a SomPlot.\n\n        Args:\n            som: Self-Organizing Map as a Som object.\n            args: Positional arguments passed to the `SomPlot` backend.r.ravel()\n            show_prototypes: Show prototypes of each node as an image.\n            show_activity: Show activity value of each node as a color.\n            kwargs: Keyword arguments passed to the `SomPlot` backend.\n        \"\"\"\n        if som.topography != \"square\":\n            raise ValueError(\n                f\"The 'array2image' plot backend only support the \"\n                f\"'square' topography, not the '{som.topography}'.\"\n            )\n\n        data = som.w_bu.reshape(som.shape + som.input_shape)\n        self.image = array_to_image(data, **kwargs)\n        self.image = add_text_border(self.image, f\"{som.params}\")\n\n    def plot(self):\n        \"\"\"Returns the plot chart.\"\"\"\n        return self.image\n\n    def save(self, filename: str, *args, **kwargs):\n        \"\"\"Saves the plot as an image.\"\"\"\n        self.image.save(filename, *args, **kwargs)\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.array2image.SomPlot.__init__","title":"<code>__init__(som, *, show_prototypes=True, show_activity=False, **kwargs)</code>","text":"<p>Creates a SomPlot.</p> <p>Parameters:</p> Name Type Description Default <code>som</code> <code>AbstractSom</code> <p>Self-Organizing Map as a Som object.</p> required <code>args</code> <p>Positional arguments passed to the <code>SomPlot</code> backend.r.ravel()</p> required <code>show_prototypes</code> <p>Show prototypes of each node as an image.</p> <code>True</code> <code>show_activity</code> <p>Show activity value of each node as a color.</p> <code>False</code> <code>kwargs</code> <p>Keyword arguments passed to the <code>SomPlot</code> backend.</p> <code>{}</code> Source code in <code>src/somap/plot_backends/array2image.py</code> <pre><code>def __init__(\n    self,\n    som: AbstractSom,\n    *,\n    show_prototypes=True,\n    show_activity=False,\n    **kwargs,\n):\n    \"\"\"Creates a SomPlot.\n\n    Args:\n        som: Self-Organizing Map as a Som object.\n        args: Positional arguments passed to the `SomPlot` backend.r.ravel()\n        show_prototypes: Show prototypes of each node as an image.\n        show_activity: Show activity value of each node as a color.\n        kwargs: Keyword arguments passed to the `SomPlot` backend.\n    \"\"\"\n    if som.topography != \"square\":\n        raise ValueError(\n            f\"The 'array2image' plot backend only support the \"\n            f\"'square' topography, not the '{som.topography}'.\"\n        )\n\n    data = som.w_bu.reshape(som.shape + som.input_shape)\n    self.image = array_to_image(data, **kwargs)\n    self.image = add_text_border(self.image, f\"{som.params}\")\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.array2image.SomPlot.plot","title":"<code>plot()</code>","text":"<p>Returns the plot chart.</p> Source code in <code>src/somap/plot_backends/array2image.py</code> <pre><code>def plot(self):\n    \"\"\"Returns the plot chart.\"\"\"\n    return self.image\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.array2image.SomPlot.save","title":"<code>save(filename, *args, **kwargs)</code>","text":"<p>Saves the plot as an image.</p> Source code in <code>src/somap/plot_backends/array2image.py</code> <pre><code>def save(self, filename: str, *args, **kwargs):\n    \"\"\"Saves the plot as an image.\"\"\"\n    self.image.save(filename, *args, **kwargs)\n</code></pre>"},{"location":"api/plot_backends/#somap.plot_backends.array2image.add_text_border","title":"<code>add_text_border(image, text, border_height=50, font_size=20, font_path=FONT_PATH)</code>","text":"<p>Adds a header with a text to an image.</p> Source code in <code>src/somap/plot_backends/array2image.py</code> <pre><code>def add_text_border(image, text, border_height=50, font_size=20, font_path=FONT_PATH):\n    \"\"\"Adds a header with a text to an image.\"\"\"\n    # Original image size\n    width, height = image.size\n\n    # New image size (with border)\n    new_height = height + border_height\n    new_image = Image.new(\"RGB\", (width, new_height), \"white\")\n\n    # Paste the original image onto the new image\n    new_image.paste(image, (0, border_height))\n\n    # Draw the text\n    draw = ImageDraw.Draw(new_image)\n    font = ImageFont.truetype(str(font_path), 14)\n\n    draw.text((0, 0), text, font=font, fill=\"black\")\n\n    return new_image\n</code></pre>"},{"location":"api/serialisation/","title":"Save &amp; load","text":"<p>Loading and saving functions.</p>"},{"location":"api/serialisation/#somap.serialisation.load","title":"<code>load(path_or_file, model_like)</code>","text":"<p>Loads model data contained in a file into a <code>model_like</code> structure.</p> <p>Parameters:</p> Name Type Description Default <code>path_or_file</code> <p>The file location to save values to or a binary file-like object.</p> required <code>model_like</code> <p>A PyTree model of same structure, and with leaves of the same type, as the PyTree being loaded. Those leaves which are loaded will replace the corresponding leaves of like.</p> required Source code in <code>src/somap/serialisation.py</code> <pre><code>def load(path_or_file, model_like):\n    \"\"\"Loads model data contained in a file into a `model_like` structure.\n\n    Args:\n        path_or_file: The file location to save values to or a binary file-like object.\n        model_like: A PyTree model of same structure, and with leaves of the same type,\n            as the PyTree being loaded. Those leaves which are loaded will replace the\n            corresponding leaves of like.\n    \"\"\"\n    return eqx.tree_deserialise_leaves(path_or_file, model_like)\n</code></pre>"},{"location":"api/serialisation/#somap.serialisation.save","title":"<code>save(path_or_file, model)</code>","text":"<p>Saves model data to file.</p> <p>Parameters:</p> Name Type Description Default <code>path_or_file</code> <p>The file location to save values to or a binary file-like object.</p> required <code>model</code> <p>The PyTree model whose leaves will be saved</p> required Source code in <code>src/somap/serialisation.py</code> <pre><code>def save(path_or_file, model):\n    \"\"\"Saves model data to file.\n\n    Args:\n        path_or_file: The file location to save values to or a binary file-like object.\n        model: The PyTree model whose leaves will be saved\n    \"\"\"\n    eqx.tree_serialise_leaves(path_or_file, model)\n</code></pre>"},{"location":"api/som/","title":"SOM","text":"<p>Catalog of different flavors of SOMs.</p> <p>To add a new SOMs, define the 2 following classes: <pre><code>class MySomParams(AbstractSomParams):\n    pass\n\nclass MySom(AbstractSom):\n    pass\n</code></pre></p>"},{"location":"api/som/#somap.som.Dsom","title":"<code>Dsom</code>","text":"<p>             Bases: <code>AbstractSom</code></p> <p>Dynamic SOM.</p> Source code in <code>src/somap/som.py</code> <pre><code>class Dsom(AbstractSom):\n    \"\"\"Dynamic SOM.\"\"\"\n\n    @staticmethod\n    def generate_algo(p: DsomParams) -&gt; SomAlgo:\n        \"\"\"Converts Dynamic SOM parameters into generic SOM functions.\"\"\"\n        return SomAlgo(\n            f_dist=EuclidianDist(),\n            f_nbh=DsomNbh(plasticity=p.plasticity),\n            f_lr=DsomLr(alpha=p.alpha),\n            f_update=SomUpdate(),\n        )\n</code></pre>"},{"location":"api/som/#somap.som.Dsom.generate_algo","title":"<code>generate_algo(p)</code>  <code>staticmethod</code>","text":"<p>Converts Dynamic SOM parameters into generic SOM functions.</p> Source code in <code>src/somap/som.py</code> <pre><code>@staticmethod\ndef generate_algo(p: DsomParams) -&gt; SomAlgo:\n    \"\"\"Converts Dynamic SOM parameters into generic SOM functions.\"\"\"\n    return SomAlgo(\n        f_dist=EuclidianDist(),\n        f_nbh=DsomNbh(plasticity=p.plasticity),\n        f_lr=DsomLr(alpha=p.alpha),\n        f_update=SomUpdate(),\n    )\n</code></pre>"},{"location":"api/som/#somap.som.DsomParams","title":"<code>DsomParams</code>","text":"<p>             Bases: <code>AbstractSomParams</code></p> <p>Dynamic SOM parameters.</p> Source code in <code>src/somap/som.py</code> <pre><code>class DsomParams(AbstractSomParams):\n    \"\"\"Dynamic SOM parameters.\"\"\"\n\n    plasticity: float | Float[Array, \"...\"]\n    alpha: float | Float[Array, \"...\"]\n</code></pre>"},{"location":"api/som/#somap.som.Ksom","title":"<code>Ksom</code>","text":"<p>             Bases: <code>AbstractSom</code></p> <p>Kohonen SOM.</p> Source code in <code>src/somap/som.py</code> <pre><code>class Ksom(AbstractSom):\n    \"\"\"Kohonen SOM.\"\"\"\n\n    @staticmethod\n    def generate_algo(p: KsomParams) -&gt; SomAlgo:\n        \"\"\"Converts Kohonen SOM parameters into generic SOM functions.\"\"\"\n        return SomAlgo(\n            f_dist=EuclidianDist(),\n            f_nbh=KsomNbh(t_f=p.t_f, sigma_i=p.sigma_i, sigma_f=p.sigma_f),\n            f_lr=KsomLr(t_f=p.t_f, alpha_i=p.alpha_i, alpha_f=p.alpha_f),\n            f_update=SomUpdate(),\n        )\n</code></pre>"},{"location":"api/som/#somap.som.Ksom.generate_algo","title":"<code>generate_algo(p)</code>  <code>staticmethod</code>","text":"<p>Converts Kohonen SOM parameters into generic SOM functions.</p> Source code in <code>src/somap/som.py</code> <pre><code>@staticmethod\ndef generate_algo(p: KsomParams) -&gt; SomAlgo:\n    \"\"\"Converts Kohonen SOM parameters into generic SOM functions.\"\"\"\n    return SomAlgo(\n        f_dist=EuclidianDist(),\n        f_nbh=KsomNbh(t_f=p.t_f, sigma_i=p.sigma_i, sigma_f=p.sigma_f),\n        f_lr=KsomLr(t_f=p.t_f, alpha_i=p.alpha_i, alpha_f=p.alpha_f),\n        f_update=SomUpdate(),\n    )\n</code></pre>"},{"location":"api/som/#somap.som.KsomParams","title":"<code>KsomParams</code>","text":"<p>             Bases: <code>AbstractSomParams</code></p> <p>Kohonen SOM parameters.</p> Source code in <code>src/somap/som.py</code> <pre><code>class KsomParams(AbstractSomParams):\n    \"\"\"Kohonen SOM parameters.\"\"\"\n\n    t_f: int | Integer[Array, \"...\"]\n    sigma_i: float | Float[Array, \"...\"]\n    sigma_f: float | Float[Array, \"...\"]\n    alpha_i: float | Float[Array, \"...\"]\n    alpha_f: float | Float[Array, \"...\"]\n</code></pre>"},{"location":"api/som/#somap.som.Som","title":"<code>Som</code>","text":"<p>             Bases: <code>AbstractSom</code></p> <p>Generic SOM.</p> <p>Distance, neighborhood, learning rate and update functions are directly specified. This is the more flexible way of defining a SOM.</p> Source code in <code>src/somap/som.py</code> <pre><code>class Som(AbstractSom):\n    \"\"\"Generic SOM.\n\n    Distance, neighborhood, learning rate and update functions are directly specified.\n    This is the more flexible way of defining a SOM.\n    \"\"\"\n\n    @staticmethod\n    def generate_algo(p: SomParams) -&gt; SomAlgo:\n        \"\"\"Identity function returning generic SOM functions.\"\"\"\n        return SomAlgo(\n            f_dist=p.f_dist,\n            f_nbh=p.f_nbh,\n            f_lr=p.f_lr,\n            f_update=p.f_update,\n        )\n</code></pre>"},{"location":"api/som/#somap.som.Som.generate_algo","title":"<code>generate_algo(p)</code>  <code>staticmethod</code>","text":"<p>Identity function returning generic SOM functions.</p> Source code in <code>src/somap/som.py</code> <pre><code>@staticmethod\ndef generate_algo(p: SomParams) -&gt; SomAlgo:\n    \"\"\"Identity function returning generic SOM functions.\"\"\"\n    return SomAlgo(\n        f_dist=p.f_dist,\n        f_nbh=p.f_nbh,\n        f_lr=p.f_lr,\n        f_update=p.f_update,\n    )\n</code></pre>"},{"location":"api/som/#somap.som.SomParams","title":"<code>SomParams</code>","text":"<p>             Bases: <code>AbstractSomParams</code>, <code>SomAlgo</code></p> <p>Generic SOM parameters.</p> <p>Same as the <code>SomAlgo</code> class but with the <code>AbstractSomParams</code> parent.</p> Source code in <code>src/somap/som.py</code> <pre><code>class SomParams(AbstractSomParams, SomAlgo):\n    \"\"\"Generic SOM parameters.\n\n    Same as the `SomAlgo` class but with the `AbstractSomParams` parent.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/som/#somap.som.StaticKsom","title":"<code>StaticKsom</code>","text":"<p>             Bases: <code>AbstractSom</code></p> <p>Time-independant Kohonen SOM.</p> Source code in <code>src/somap/som.py</code> <pre><code>class StaticKsom(AbstractSom):\n    \"\"\"Time-independant Kohonen SOM.\"\"\"\n\n    @staticmethod\n    def generate_algo(p: StaticKsomParams) -&gt; SomAlgo:\n        \"\"\"Converts Static Kohonen SOM parameters into generic SOM functions.\"\"\"\n        return SomAlgo(\n            f_dist=EuclidianDist(),\n            f_nbh=GaussianNbh(sigma=p.sigma),\n            f_lr=ConstantLr(alpha=p.alpha),\n            f_update=SomUpdate(),\n        )\n</code></pre>"},{"location":"api/som/#somap.som.StaticKsom.generate_algo","title":"<code>generate_algo(p)</code>  <code>staticmethod</code>","text":"<p>Converts Static Kohonen SOM parameters into generic SOM functions.</p> Source code in <code>src/somap/som.py</code> <pre><code>@staticmethod\ndef generate_algo(p: StaticKsomParams) -&gt; SomAlgo:\n    \"\"\"Converts Static Kohonen SOM parameters into generic SOM functions.\"\"\"\n    return SomAlgo(\n        f_dist=EuclidianDist(),\n        f_nbh=GaussianNbh(sigma=p.sigma),\n        f_lr=ConstantLr(alpha=p.alpha),\n        f_update=SomUpdate(),\n    )\n</code></pre>"},{"location":"api/som/#somap.som.StaticKsomParams","title":"<code>StaticKsomParams</code>","text":"<p>             Bases: <code>AbstractSomParams</code></p> <p>Time-independant Kohonen SOM parameters.</p> Source code in <code>src/somap/som.py</code> <pre><code>class StaticKsomParams(AbstractSomParams):\n    \"\"\"Time-independant Kohonen SOM parameters.\"\"\"\n\n    sigma: float | Float[Array, \"...\"]\n    alpha: float | Float[Array, \"...\"]\n</code></pre>"},{"location":"api/update/","title":"Update","text":"<p>Catalog of update functions.</p>"},{"location":"api/update/#somap.update.AbstractUpdate","title":"<code>AbstractUpdate</code>","text":"<p>             Bases: <code>Module</code></p> <p>Ensures that all update functions have the same signatures.</p> Source code in <code>src/somap/update.py</code> <pre><code>class AbstractUpdate(eqx.Module):\n    \"\"\"Ensures that all update functions have the same signatures.\"\"\"\n\n    @abstractmethod\n    def __call__(self, lr, nbh, input_bu, w_bu):\n        \"\"\"SOM Update function.\n\n        Args:\n            lr: Learning rate.\n            nbh: Neighborhood.\n            input_bu: Data input.\n            w_bu: Prototype weights.\n\n        Returns:\n            The updated prototype weights.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/update/#somap.update.AbstractUpdate.__call__","title":"<code>__call__(lr, nbh, input_bu, w_bu)</code>  <code>abstractmethod</code>","text":"<p>SOM Update function.</p> <p>Parameters:</p> Name Type Description Default <code>lr</code> <p>Learning rate.</p> required <code>nbh</code> <p>Neighborhood.</p> required <code>input_bu</code> <p>Data input.</p> required <code>w_bu</code> <p>Prototype weights.</p> required <p>Returns:</p> Type Description <p>The updated prototype weights.</p> Source code in <code>src/somap/update.py</code> <pre><code>@abstractmethod\ndef __call__(self, lr, nbh, input_bu, w_bu):\n    \"\"\"SOM Update function.\n\n    Args:\n        lr: Learning rate.\n        nbh: Neighborhood.\n        input_bu: Data input.\n        w_bu: Prototype weights.\n\n    Returns:\n        The updated prototype weights.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/update/#somap.update.CyclicSomUpdate","title":"<code>CyclicSomUpdate</code>","text":"<p>             Bases: <code>AbstractUpdate</code></p> <p>Cyclic update functions.</p> Source code in <code>src/somap/update.py</code> <pre><code>@experimental_warning\nclass CyclicSomUpdate(AbstractUpdate):\n    \"\"\"Cyclic update functions.\"\"\"\n\n    def __call__(self, lr, nbh, input_bu, w_bu):\n        \"\"\"Updates the prototype weights where 0 is the same as 1.\"\"\"\n        # convert [0:1] float range into [0:255] integer range\n        input_bu_uint8 = (input_bu * 255).astype(jnp.uint8)\n        w_bu_uint8 = (w_bu * 255).astype(jnp.uint8)\n\n        # interpret the diff as an unsigned int8\n        # diff is between -1 and 1\n        diff = (input_bu_uint8 - w_bu_uint8).astype(jnp.int8) / 128.0\n\n        # out may escape the [0:1] interval, so it needs a modulo 1\n        out = (lr * nbh)[:, :, jnp.newaxis] * diff + w_bu\n        out = out % 1\n\n        return out\n</code></pre>"},{"location":"api/update/#somap.update.CyclicSomUpdate.__call__","title":"<code>__call__(lr, nbh, input_bu, w_bu)</code>","text":"<p>Updates the prototype weights where 0 is the same as 1.</p> Source code in <code>src/somap/update.py</code> <pre><code>def __call__(self, lr, nbh, input_bu, w_bu):\n    \"\"\"Updates the prototype weights where 0 is the same as 1.\"\"\"\n    # convert [0:1] float range into [0:255] integer range\n    input_bu_uint8 = (input_bu * 255).astype(jnp.uint8)\n    w_bu_uint8 = (w_bu * 255).astype(jnp.uint8)\n\n    # interpret the diff as an unsigned int8\n    # diff is between -1 and 1\n    diff = (input_bu_uint8 - w_bu_uint8).astype(jnp.int8) / 128.0\n\n    # out may escape the [0:1] interval, so it needs a modulo 1\n    out = (lr * nbh)[:, :, jnp.newaxis] * diff + w_bu\n    out = out % 1\n\n    return out\n</code></pre>"},{"location":"api/update/#somap.update.SomUpdate","title":"<code>SomUpdate</code>","text":"<p>             Bases: <code>AbstractUpdate</code></p> <p>Generic update function.</p> Source code in <code>src/somap/update.py</code> <pre><code>class SomUpdate(AbstractUpdate):\n    \"\"\"Generic update function.\"\"\"\n\n    def __call__(\n        self,\n        lr: Float[Array, \"...\"],\n        nbh: Float[Array, \"...\"],\n        input_bu: Float[Array, \"...\"],\n        w_bu: Float[Array, \"...\"],\n    ) -&gt; Float[Array, \"...\"]:\n        \"\"\"Updates the prototype weights.\"\"\"\n        out = w_bu + (lr * nbh)[:, :, jnp.newaxis] * (input_bu - w_bu)\n        return jnp.clip(out, 0, 1.0)\n</code></pre>"},{"location":"api/update/#somap.update.SomUpdate.__call__","title":"<code>__call__(lr, nbh, input_bu, w_bu)</code>","text":"<p>Updates the prototype weights.</p> Source code in <code>src/somap/update.py</code> <pre><code>def __call__(\n    self,\n    lr: Float[Array, \"...\"],\n    nbh: Float[Array, \"...\"],\n    input_bu: Float[Array, \"...\"],\n    w_bu: Float[Array, \"...\"],\n) -&gt; Float[Array, \"...\"]:\n    \"\"\"Updates the prototype weights.\"\"\"\n    out = w_bu + (lr * nbh)[:, :, jnp.newaxis] * (input_bu - w_bu)\n    return jnp.clip(out, 0, 1.0)\n</code></pre>"}]}